[[jdbc-parameter-handling]]
= 参数和数据值处理的常见问题

TODAY Framework 的 JDBC 支持提供的不同方法中存在参数和数据值处理的常见问题。本节介绍如何解决这些问题。


[[jdbc-type-information]]
== 为参数提供 SQL 类型信息

通常，Infra 根据传入的参数类型确定参数的 SQL 类型。可以显式提供设置参数值时要使用的 SQL 类型。这有时对于正确设置 `NULL` 值是必要的。

您可以通过多种方式提供 SQL 类型信息：

* `JdbcTemplate` 的许多更新和查询方法都采用 `int` 数组形式的附加参数。此数组用于通过使用 `java.sql.Types` 类中的常量值来指示相应参数的 SQL 类型。为每个参数提供一个条目。
* 您可以使用 `SqlParameterValue` 类来包装需要此附加信息的参数值。为此，请为每个值创建一个新实例，并在构造函数中传入 SQL 类型和参数值。您还可以为数值提供可选的比例参数。
* 对于使用命名参数的方法，您可以使用 `SqlParameterSource` 类、`BeanPropertySqlParameterSource` 或 `MapSqlParameterSource`。它们都有用于为任何命名参数值注册 SQL 类型的方法。


[[jdbc-lob]]
== 处理 BLOB 和 CLOB 对象

您可以在数据库中存储图像、其他二进制数据和大块文本。这些大对象对于二进制数据称为 BLOB（二进制大对象），对于字符数据称为 CLOB（字符大对象）。在 Infra 中，您可以通过直接使用 `JdbcTemplate` 以及使用 RDBMS 对象和 `SimpleJdbc` 类提供的更高级抽象来处理这些大对象。所有这些方法都使用 `LobHandler` 接口的实现来进行 LOB（大对象）数据的实际管理。`LobHandler` 通过 `getLobCreator` 方法提供对 `LobCreator` 类的访问，该类用于创建要插入的新 LOB 对象。

`LobCreator` 和 `LobHandler` 为 LOB 输入和输出提供以下支持：

* BLOB
** `byte[]`: `getBlobAsBytes` 和 `setBlobAsBytes`
** `InputStream`: `getBlobAsBinaryStream` and `setBlobAsBinaryStream`
* CLOB
** `String`: `getClobAsString` 和 `setClobAsString`
** `InputStream`: `getClobAsAsciiStream` 和 `setClobAsAsciiStream`
** `Reader`: `getClobAsCharacterStream` 和 `setClobAsCharacterStream`

下一个示例显示了如何创建和插入 BLOB。稍后我们将展示如何从数据库中读取它。

此示例使用 `JdbcTemplate` 和 `AbstractLobCreatingPreparedStatementCallback` 的实现。它实现了一个方法 `setValues`。此方法提供了一个 `LobCreator`，我们使用它来设置 SQL 插入语句中 LOB 列的值。

对于此示例，我们假设有一个变量 `lobHandler`，它已设置为 `DefaultLobHandler` 的实例。通常通过依赖注入设置此值。

以下示例显示了如何创建和插入 BLOB：

[tabs]
======
Java::
+
[source,java,indent=0,subs="verbatim,quotes",role="primary"]
----
final File blobIn = new File("spring2004.jpg");
final InputStream blobIs = new FileInputStream(blobIn);
final File clobIn = new File("large.txt");
final InputStream clobIs = new FileInputStream(clobIn);
final InputStreamReader clobReader = new InputStreamReader(clobIs);

jdbcTemplate.execute(
  "INSERT INTO lob_table (id, a_clob, a_blob) VALUES (?, ?, ?)",
  new AbstractLobCreatingPreparedStatementCallback(lobHandler) {  // <1>
    protected void setValues(PreparedStatement ps, LobCreator lobCreator) throws SQLException {
      ps.setLong(1, 1L);
      lobCreator.setClobAsCharacterStream(ps, 2, clobReader, (int)clobIn.length());  // <2>
      lobCreator.setBlobAsBinaryStream(ps, 3, blobIs, (int)blobIn.length());  // <3>
    }
  }
);

blobIs.close();
clobReader.close();
----
<1> 传入 `lobHandler`，在此示例中为普通的 `DefaultLobHandler`。
<2> 使用 `setClobAsCharacterStream` 方法传入 CLOB 的内容。
<3> 使用 `setBlobAsBinaryStream` 方法传入 BLOB 的内容。

======

[NOTE]
====
如果您在从 `DefaultLobHandler.getLobCreator()` 返回的 `LobCreator` 上调用 `setBlobAsBinaryStream`、`setClobAsAsciiStream` 或 `setClobAsCharacterStream` 方法，则可以选择为 `contentLength` 参数指定负值。如果指定的内容长度为负数，则 `DefaultLobHandler` 使用不带长度参数的 set-stream 方法的 JDBC 4.0 变体。否则，它会将指定的长度传递给驱动程序。

请参阅您使用的 JDBC 驱动程序的文档，以验证它是否支持在不提供内容长度的情况下流式传输 LOB。
====

现在是从数据库读取 LOB 数据的时候了。同样，您使用具有相同实例变量 `lobHandler` 和对 `DefaultLobHandler` 的引用的 `JdbcTemplate`。以下示例显示了如何执行此操作：

[tabs]
======
Java::
+
[source,java,indent=0,subs="verbatim,quotes",role="primary"]
----
List<Map<String, Object>> l = jdbcTemplate.query("select id, a_clob, a_blob from lob_table",
  new RowMapper<Map<String, Object>>() {
    public Map<String, Object> mapRow(ResultSet rs, int i) throws SQLException {
      Map<String, Object> results = new HashMap<String, Object>();
      String clobText = lobHandler.getClobAsString(rs, "a_clob");  // <1>
      results.put("CLOB", clobText);
      byte[] blobBytes = lobHandler.getBlobAsBytes(rs, "a_blob");  // <2>
      results.put("BLOB", blobBytes);
      return results;
    }
  });
----
<1> 使用 `getClobAsString` 方法检索 CLOB 的内容。
<2> 使用 `getBlobAsBytes` 方法检索 BLOB 的内容。

======


[[jdbc-in-clause]]
== 为 IN 子句传入值列表

SQL 标准允许根据包含可变值列表的表达式选择行。典型的例子是 `select * from T_ACTOR where id in (1, 2, 3)`。JDBC 标准不直接支持预处理语句的此变量列表。您不能声明可变数量的占位符。您需要准备好具有所需占位符数量的多种变体，或者一旦知道需要多少占位符，就需要动态生成 SQL 字符串。`NamedParameterJdbcTemplate` 中提供的命名参数支持采用后一种方法。您可以将值作为简单值的 `java.util.List`（或任何 `Iterable`）传入。此列表用于将所需的占位符插入实际的 SQL 语句中，并在语句执行期间传入值。

NOTE: 传入许多值时要小心。JDBC 标准不保证您可以为 `IN` 表达式列表使用超过 100 个值。各种数据库都超过了这个数字，但它们通常对允许多少个值有一个硬性限制。例如，Oracle 的限制是 1000。

除了值列表中的原始值之外，您还可以创建对象数组的 `java.util.List`。此列表可以支持为 `in` 子句定义的多个表达式，例如 `+++select * from T_ACTOR where (id, last_name) in ((1, 'Johnson'), (2, 'Harrop'))+++`。当然，这要求您的数据库支持此语法。


[[jdbc-complex-types]]
== 处理存储过程调用的复杂类型

当您调用存储过程时，有时可以使用特定于数据库的复杂类型。为了适应这些类型，Infra 提供了 `SqlReturnType` 以在从存储过程调用返回时处理它们，以及 `SqlTypeValue` 以在将它们作为参数传递给存储过程时处理它们。

`SqlReturnType` 接口有一个必须实现的单一方法（名为 `getTypeValue`）。此接口用作 `SqlOutParameter` 声明的一部分。以下示例显示返回用户声明类型 `ITEM_TYPE` 的 Oracle `STRUCT` 对象的值：

[tabs]
======
Java::
+
[source,java,indent=0,subs="verbatim,quotes",role="primary"]
----
public class TestItemStoredProcedure extends StoredProcedure {

  public TestItemStoredProcedure(DataSource dataSource) {
    // ...
    declareParameter(new SqlOutParameter("item", OracleTypes.STRUCT, "ITEM_TYPE",
      (CallableStatement cs, int colIndx, int sqlType, String typeName) -> {
        STRUCT struct = (STRUCT) cs.getObject(colIndx);
        Object[] attr = struct.getAttributes();
        TestItem item = new TestItem();
        item.setId(((Number) attr[0]).longValue());
        item.setDescription((String) attr[1]);
        item.setExpirationDate((java.util.Date) attr[2]);
        return item;
      }));
    // ...
  }
----
