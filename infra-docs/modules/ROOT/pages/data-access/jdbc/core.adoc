[[jdbc-core]]
= 使用 JDBC 核心类控制基本 JDBC 处理和错误处理

本节介绍如何使用 JDBC 核心类来控制基本的 JDBC 处理，包括错误处理。它包含以下主题：

* xref:data-access/jdbc/core.adoc#jdbc-JdbcTemplate[使用 `JdbcTemplate`]
* xref:data-access/jdbc/core.adoc#jdbc-NamedParameterJdbcTemplate[使用 `NamedParameterJdbcTemplate`]
* xref:data-access/jdbc/core.adoc#jdbc-JdbcClient[统一的 JDBC 查询/更新操作：`JdbcClient`]
* xref:data-access/jdbc/core.adoc#jdbc-SQLExceptionTranslator[使用 `SQLExceptionTranslator`]
* xref:data-access/jdbc/core.adoc#jdbc-statements-executing[运行语句]
* xref:data-access/jdbc/core.adoc#jdbc-statements-querying[运行查询]
* xref:data-access/jdbc/core.adoc#jdbc-updates[更新数据库]
* xref:data-access/jdbc/core.adoc#jdbc-auto-generated-keys[检索自动生成的键]


[[jdbc-JdbcTemplate]]
== 使用 `JdbcTemplate`

`JdbcTemplate` 是 JDBC 核心包中的中心类。它处理资源的创建和释放，这有助于您避免常见错误，例如忘记关闭连接。它执行核心 JDBC 工作流的基本任务（例如语句创建和执行），让应用程序代码提供 SQL 并提取结果。`JdbcTemplate` 类：

* 运行 SQL 查询
* 更新语句和存储过程调用
* 执行对 `ResultSet` 实例的迭代以及返回参数值的提取。
* 捕获 JDBC 异常并将其转换为 `infra.dao` 包中定义的通用、更具信息性的异常层次结构。（请参阅 xref:data-access/dao.adoc#dao-exceptions[一致的异常层次结构]。）

当您在代码中使用 `JdbcTemplate` 时，您只需要实现回调接口，给它们一个明确定义的契约。给定 `JdbcTemplate` 类提供的 `Connection`，`PreparedStatementCreator` 回调接口创建一个预处理语句，提供 SQL 和任何必要的参数。对于创建可调用语句的 `CallableStatementCreator` 接口也是如此。`RowCallbackHandler` 接口从 `ResultSet` 的每一行提取值。

您可以在 DAO 实现中通过使用 `DataSource` 引用直接实例化来使用 `JdbcTemplate`，也可以在 Infra IoC 容器中配置它并将其作为 bean 引用提供给 DAO。

NOTE: `DataSource` 应始终在 Infra IoC 容器中配置为 bean。在第一种情况下，bean 直接提供给服务；在第二种情况下，它被提供给准备好的模板。

此类发出的所有 SQL 都以 `DEBUG` 级别记录在与模板实例的完全限定类名相对应的类别下（通常是 `JdbcTemplate`，但如果您使用 `JdbcTemplate` 类的自定义子类，则可能会有所不同）。

以下部分提供了一些 `JdbcTemplate` 使用示例。这些示例并未列出 `JdbcTemplate` 公开的所有功能。
请参阅随附的 {today-framework-api}/jdbc/core/JdbcTemplate.html[javadoc] 以获取该信息。

[[jdbc-JdbcTemplate-examples-query]]
=== 查询 (`SELECT`)

以下查询获取关系中的行数：

[tabs]
======
Java::
+
[source,java,indent=0,subs="verbatim,quotes",role="primary"]
----
int rowCount = this.jdbcTemplate.queryForObject("select count(*) from t_actor", Integer.class);
----

======

以下查询使用绑定变量：

[tabs]
======
Java::
+
[source,java,indent=0,subs="verbatim,quotes",role="primary"]
----
int countOfActorsNamedJoe = this.jdbcTemplate.queryForObject(
    "select count(*) from t_actor where first_name = ?", Integer.class, "Joe");
----
======


以下查询查找一个 `String`：

[tabs]
======
Java::
+
[source,java,indent=0,subs="verbatim,quotes",role="primary"]
----
String lastName = this.jdbcTemplate.queryForObject(
    "select last_name from t_actor where id = ?", String.class, 1212L);
----

======

以下查询查找并填充单个域对象：

[tabs]
======
Java::
+
[source,java,indent=0,subs="verbatim,quotes",role="primary"]
----
Actor actor = jdbcTemplate.queryForObject(
    "select first_name, last_name from t_actor where id = ?",
    (resultSet, rowNum) -> {
      Actor newActor = new Actor();
      newActor.setFirstName(resultSet.getString("first_name"));
      newActor.setLastName(resultSet.getString("last_name"));
      return newActor;
    },
    1212L);
----

======

以下查询查找并填充域对象列表：

[tabs]
======
Java::
+
[source,java,indent=0,subs="verbatim,quotes",role="primary"]
----
List<Actor> actors = this.jdbcTemplate.query(
    "select first_name, last_name from t_actor",
    (resultSet, rowNum) -> {
      Actor actor = new Actor();
      actor.setFirstName(resultSet.getString("first_name"));
      actor.setLastName(resultSet.getString("last_name"));
      return actor;
    });
----
======

如果最后两段代码实际上存在于同一个应用程序中，那么删除两个 `RowMapper` lambda 表达式中存在的重复并将它们提取到一个字段中是有意义的，然后可以根据需要由 DAO 方法引用该字段。
例如，最好将前面的代码片段编写如下：

[tabs]
======
Java::
+
[source,java,indent=0,subs="verbatim,quotes",role="primary"]
----
private final RowMapper<Actor> actorRowMapper = (resultSet, rowNum) -> {
  Actor actor = new Actor();
  actor.setFirstName(resultSet.getString("first_name"));
  actor.setLastName(resultSet.getString("last_name"));
  return actor;
};

public List<Actor> findAllActors() {
  return this.jdbcTemplate.query("select first_name, last_name from t_actor", actorRowMapper);
}
----

======

[[jdbc-JdbcTemplate-examples-update]]
=== 使用 `JdbcTemplate` 进行更新 (`INSERT`, `UPDATE`, 和 `DELETE`)

您可以使用 `update(..)` 方法执行插入、更新和删除操作。
参数值通常作为可变参数提供，或者作为对象数组提供。

以下示例插入一个新条目：

[tabs]
======
Java::
+
[source,java,indent=0,subs="verbatim,quotes",role="primary"]
----
this.jdbcTemplate.update(
    "insert into t_actor (first_name, last_name) values (?, ?)", "Leonor", "Watling");
----

======

以下示例更新现有条目：

[tabs]
======
Java::
+
[source,java,indent=0,subs="verbatim,quotes",role="primary"]
----
this.jdbcTemplate.update(
    "update t_actor set last_name = ? where id = ?", "Banjo", 5276L);
----

======

以下示例删除一个条目：

[tabs]
======
Java::
+
[source,java,indent=0,subs="verbatim,quotes",role="primary"]
----
this.jdbcTemplate.update(
    "delete from t_actor where id = ?", Long.valueOf(actorId));
----

======

[[jdbc-JdbcTemplate-examples-other]]
=== 其他 `JdbcTemplate` 操作

您可以使用 `execute(..)` 方法运行任何任意 SQL。因此，该方法通常用于 DDL 语句。它被大量重载，具有接受回调接口、绑定变量数组等的变体。以下示例创建一个表：

[tabs]
======
Java::
+
[source,java,indent=0,subs="verbatim,quotes",role="primary"]
----
this.jdbcTemplate.execute("create table mytable (id integer, name varchar(100))");
----

======

以下示例调用存储过程：

[tabs]
======
Java::
+
[source,java,indent=0,subs="verbatim,quotes",role="primary"]
----
this.jdbcTemplate.update(
    "call SUPPORT.REFRESH_ACTORS_SUMMARY(?)",	Long.valueOf(unionId));
----

======


更复杂的存储过程支持在 xref:data-access/jdbc/object.adoc#jdbc-StoredProcedure[稍后介绍]。

[[jdbc-JdbcTemplate-idioms]]
=== `JdbcTemplate` 最佳实践

`JdbcTemplate` 类的实例一旦配置好就是线程安全的。
这很重要，因为这意味着您可以配置 `JdbcTemplate` 的单个实例，然后安全地将此共享引用注入到多个 DAO（或存储库）中。
`JdbcTemplate` 是有状态的，因为它维护对 `DataSource` 的引用，但此状态不是会话状态。

使用 `JdbcTemplate` 类（以及关联的 xref:data-access/jdbc/core.adoc#jdbc-NamedParameterJdbcTemplate[`NamedParameterJdbcTemplate`] 类）时的常见做法是在 Infra 配置文件中配置 `DataSource`，然后将该共享 `DataSource` bean 依赖注入到您的 DAO 类中。`JdbcTemplate` 在 `DataSource` 的 setter 中创建。这导致 DAO 类似于以下内容：

--
[tabs]
======
Java::
+
[source,java,indent=0,subs="verbatim,quotes",role="primary"]
----

public interface CorporateEventDao {
}

public class JdbcCorporateEventDao implements CorporateEventDao {

  private JdbcTemplate jdbcTemplate;

  public void setDataSource(DataSource dataSource) {
    this.jdbcTemplate = new JdbcTemplate(dataSource);
  }

  // CorporateEventDao 上方法的 JDBC 支持实现如下...
}
----

======
--

以下示例显示了相应的配置：

[source,java]
----
@Configuration
public class JdbcCorporateEventDaoConfiguration {

  @Bean
  static JdbcCorporateEventDao corporateEventDao(DataSource dataSource) {
    return new JdbcCorporateEventDao();
  }

  @Bean(destroyMethod = "close")
  static BasicDataSource dataSource() {
    BasicDataSource dataSource = new BasicDataSource();
    dataSource.setDriverClassName("org.hsqldb.jdbcDriver");
    dataSource.setUrl("jdbc:hsqldb:hsql://localhost:");
    dataSource.setUsername("sa");
    dataSource.setPassword("");
    return dataSource;
  }

}
----

显式配置的另一种替代方法是使用组件扫描和注解支持进行依赖注入。在这种情况下，您可以使用 `@Repository` 注解类（这使其成为组件扫描的候选者）。以下示例显示了如何执行此操作：

[source,java]
----

public interface CorporateEventRepository {
}

@Repository
public class JdbcCorporateEventRepository implements CorporateEventRepository {

  private JdbcTemplate jdbcTemplate;

  // 隐式自动装配 DataSource 构造函数参数
  public JdbcCorporateEventRepository(DataSource dataSource) {
    this.jdbcTemplate = new JdbcTemplate(dataSource);
  }

  // CorporateEventRepository 上方法的 JDBC 支持实现如下...
}
----

以下示例显示了相应的配置：

[source,java]
----
@Configuration
@ComponentScan("infra.docs.dataaccess.jdbc")
public class JdbcCorporateEventRepositoryConfiguration {

  @Bean(destroyMethod = "close")
  BasicDataSource dataSource() {
    BasicDataSource dataSource = new BasicDataSource();
    dataSource.setDriverClassName("org.hsqldb.jdbcDriver");
    dataSource.setUrl("jdbc:hsqldb:hsql://localhost:");
    dataSource.setUsername("sa");
    dataSource.setPassword("");
    return dataSource;
  }

}
----

如果您使用 Infra `JdbcDaoSupport` 类，并且您的各种 JDBC 支持的 DAO 类继承自它，则您的子类从 `JdbcDaoSupport` 类继承 `setDataSource(..)` 方法。您可以选择是否继承此类。`JdbcDaoSupport` 类仅为方便起见而提供。

无论您选择使用（或不使用）哪种上述模板初始化样式，几乎没有必要在每次要运行 SQL 时都创建 `JdbcTemplate` 类的新实例。一旦配置好，`JdbcTemplate` 实例就是线程安全的。
如果您的应用程序访问多个数据库，您可能需要多个 `JdbcTemplate` 实例，这需要多个 `DataSources`，随后需要多个不同配置的 `JdbcTemplate` 实例。


[[jdbc-NamedParameterJdbcTemplate]]
== 使用 `NamedParameterJdbcTemplate`

`NamedParameterJdbcTemplate` 类增加了使用命名参数编程 JDBC 语句的支持，而不是仅使用经典占位符 (`'?'`) 参数编程 JDBC 语句。`NamedParameterJdbcTemplate` 类包装了一个 `JdbcTemplate` 并委托给包装的 `JdbcTemplate` 来完成其大部分工作。本节仅描述 `NamedParameterJdbcTemplate` 类与 `JdbcTemplate` 本身不同的那些方面——即使用命名参数编程 JDBC 语句。以下示例显示了如何使用 `NamedParameterJdbcTemplate`：

[tabs]
======
Java::
+
[source,java,indent=0,subs="verbatim,quotes",role="primary"]
----
// 一些基于 JDBC 的 DAO 类...
private NamedParameterJdbcTemplate namedParameterJdbcTemplate;

public void setDataSource(DataSource dataSource) {
  this.namedParameterJdbcTemplate = new NamedParameterJdbcTemplate(dataSource);
}

public int countOfActorsByFirstName(String firstName) {
  String sql = "select count(*) from t_actor where first_name = :first_name";
  SqlParameterSource namedParameters = new MapSqlParameterSource("first_name", firstName);
  return this.namedParameterJdbcTemplate.queryForObject(sql, namedParameters, Integer.class);
}
----

======

注意在分配给 `sql` 变量的值中使用了命名参数符号，以及插入到 `namedParameters` 变量（类型为 `MapSqlParameterSource`）中的相应值。

或者，您可以使用基于 `Map` 的样式将命名参数及其相应值传递给 `NamedParameterJdbcTemplate` 实例。`NamedParameterJdbcOperations` 公开并由 `NamedParameterJdbcTemplate` 类实现的其余方法遵循类似的模式，此处不再赘述。

以下示例显示了基于 `Map` 的样式的使用：

[tabs]
======
Java::
+
[source,java,indent=0,subs="verbatim,quotes",role="primary"]
----
// 一些基于 JDBC 的 DAO 类...
private NamedParameterJdbcTemplate namedParameterJdbcTemplate;

public void setDataSource(DataSource dataSource) {
  this.namedParameterJdbcTemplate = new NamedParameterJdbcTemplate(dataSource);
}

public int countOfActorsByFirstName(String firstName) {
  String sql = "select count(*) from t_actor where first_name = :first_name";
  Map<String, String> namedParameters = Collections.singletonMap("first_name", firstName);
  return this.namedParameterJdbcTemplate.queryForObject(sql, namedParameters, Integer.class);
}
----

======

与 `NamedParameterJdbcTemplate` 相关（并且存在于同一 Java 包中）的一个很好的特性是 `SqlParameterSource` 接口。您已经在前面的代码片段之一中看到了此接口实现的示例（`MapSqlParameterSource` 类）。`SqlParameterSource` 是 `NamedParameterJdbcTemplate` 的命名参数值源。`MapSqlParameterSource` 类是一个简单的实现，它是围绕 `java.util.Map` 的适配器，其中键是参数名称，值是参数值。

另一个 `SqlParameterSource` 实现是 `BeanPropertySqlParameterSource` 类。此类包装任意 JavaBean（即遵守 https://www.oracle.com/technetwork/java/javase/documentation/spec-136004.html[JavaBean 约定] 的类的实例），并使用包装的 JavaBean 的属性作为命名参数值的来源。

以下示例显示了一个典型的 JavaBean：

[tabs]
======
Java::
+
[source,java,indent=0,subs="verbatim,quotes",role="primary"]
----
public class Actor {

  private Long id;
  private String firstName;
  private String lastName;

  public String getFirstName() {
    return this.firstName;
  }

  public String getLastName() {
    return this.lastName;
  }

  public Long getId() {
    return this.id;
  }

  // 省略 setter...
}
----
======

以下示例使用 `NamedParameterJdbcTemplate` 返回前面示例中显示的类的成员计数：

[tabs]
======
Java::
+
[source,java,indent=0,subs="verbatim,quotes",role="primary"]
----
// 一些基于 JDBC 的 DAO 类...
private NamedParameterJdbcTemplate namedParameterJdbcTemplate;

public void setDataSource(DataSource dataSource) {
  this.namedParameterJdbcTemplate = new NamedParameterJdbcTemplate(dataSource);
}

public int countOfActors(Actor exampleActor) {
  // 注意命名参数如何匹配上述 'Actor' 类的属性
  String sql = "select count(*) from t_actor where first_name = :firstName and last_name = :lastName";
  SqlParameterSource namedParameters = new BeanPropertySqlParameterSource(exampleActor);
  return this.namedParameterJdbcTemplate.queryForObject(sql, namedParameters, Integer.class);
}
----

======

请记住，`NamedParameterJdbcTemplate` 类包装了一个经典的 `JdbcTemplate` 模板。如果您需要访问包装的 `JdbcTemplate` 实例以访问仅在 `JdbcTemplate` 类中存在的功能，您可以使用 `getJdbcOperations()` 方法通过 `JdbcOperations` 接口访问包装的 `JdbcTemplate`。

另请参阅 xref:data-access/jdbc/core.adoc#jdbc-JdbcTemplate-idioms[`JdbcTemplate` 最佳实践]，以获取有关在应用程序上下文中使用 `NamedParameterJdbcTemplate` 类的指南。


[[jdbc-JdbcClient]]
== 统一的 JDBC 查询/更新操作：`JdbcClient`

从 5.0 开始，`NamedParameterJdbcTemplate` 的命名参数语句和常规 `JdbcTemplate` 的位置参数语句都可以通过具有流畅交互模型的统一客户端 API 使用。

例如，使用位置参数：

[source,java,indent=0,subs="verbatim,quotes"]
----
private JdbcClient jdbcClient = JdbcClient.create(dataSource);

public int countOfActorsByFirstName(String firstName) {
  return this.jdbcClient.sql("select count(*) from t_actor where first_name = ?")
      .param(firstName)
      .query(Integer.class).single();
}
----

例如，使用命名参数：

[source,java,indent=0,subs="verbatim,quotes"]
----
private JdbcClient jdbcClient = JdbcClient.create(dataSource);

public int countOfActorsByFirstName(String firstName) {
  return this.jdbcClient.sql("select count(*) from t_actor where first_name = :firstName")
      .param("firstName", firstName)
      .query(Integer.class).single();
}
----

`RowMapper` 功能也可用，具有灵活的结果解析：

[source,java,indent=0,subs="verbatim,quotes"]
----
List<Actor> actors = this.jdbcClient.sql("select first_name, last_name from t_actor")
    .query((rs, rowNum) -> new Actor(rs.getString("first_name"), rs.getString("last_name")))
    .list();
----

除了自定义 `RowMapper` 之外，您还可以指定要映射到的类。
例如，假设 `Actor` 具有 `firstName` 和 `lastName` 属性作为记录类、自定义构造函数、bean 属性或普通字段：

[source,java,indent=0,subs="verbatim,quotes"]
----
List<Actor> actors = this.jdbcClient.sql("select first_name, last_name from t_actor")
    .query(Actor.class)
    .list();
----

使用所需的单个对象结果：

[source,java,indent=0,subs="verbatim,quotes"]
----
Actor actor = this.jdbcClient.sql("select first_name, last_name from t_actor where id = ?")
    .param(1212L)
    .query(Actor.class)
    .single();
----

使用 `java.util.Optional` 结果：

[source,java,indent=0,subs="verbatim,quotes"]
----
Optional<Actor> actor = this.jdbcClient.sql("select first_name, last_name from t_actor where id = ?")
    .param(1212L)
    .query(Actor.class)
    .optional();
----

对于更新语句：

[source,java,indent=0,subs="verbatim,quotes"]
----
this.jdbcClient.sql("insert into t_actor (first_name, last_name) values (?, ?)")
    .param("Leonor").param("Watling")
    .update();
----

或者带有命名参数的更新语句：

[source,java,indent=0,subs="verbatim,quotes"]
----
this.jdbcClient.sql("insert into t_actor (first_name, last_name) values (:firstName, :lastName)")
    .param("firstName", "Leonor").param("lastName", "Watling")
    .update();
----

除了单个命名参数之外，您还可以指定参数源对象 –
例如，记录类、具有 bean 属性的类或提供 `firstName` 和 `lastName` 属性的普通字段持有者，例如上面的 `Actor` 类：

[source,java,indent=0,subs="verbatim,quotes"]
----
this.jdbcClient.sql("insert into t_actor (first_name, last_name) values (:firstName, :lastName)")
    .paramSource(new Actor("Leonor", "Watling")
    .update();
----

上述参数以及查询结果的自动 `Actor` 类映射是通过隐式 `SimplePropertySqlParameterSource` 和 `SimplePropertyRowMapper` 策略提供的，这些策略也可供直接使用。它们可以作为 `BeanPropertySqlParameterSource` 和 `BeanPropertyRowMapper`/`DataClassRowMapper` 的通用替代品，也可用于 `JdbcTemplate` 和 `NamedParameterJdbcTemplate` 本身。

NOTE: `JdbcClient` 是 JDBC 查询/更新语句的灵活但简化的外观。
高级功能（如批量插入和存储过程调用）通常需要额外的自定义：对于 `JdbcClient` 中不可用的任何此类功能，请考虑 Infra `SimpleJdbcInsert` 和 `SimpleJdbcCall` 类或纯直接 `JdbcTemplate` 用法。


[[jdbc-SQLExceptionTranslator]]
== 使用 `SQLExceptionTranslator`

`SQLExceptionTranslator` 是一个接口，由可以在 ``SQLException`` 和 Infra 自己的 `infra.dao.DataAccessException` 之间进行转换的类实现，后者与数据访问策略无关。实现可以是通用的（例如，使用 JDBC 的 SQLState 代码）或专有的（例如，使用 Oracle 错误代码）以获得更高的精度。这种异常转换机制用于通用的 `JdbcTemplate` 和 `JdbcTransactionManager` 入口点之后，它们不传播 `SQLException`，而是传播 `DataAccessException`。

NOTE: 从 6.0 开始，默认的异常转换器是 `SQLExceptionSubclassTranslator`，它通过一些额外的检查检测 JDBC 4 `SQLException` 子类，并通过 `SQLStateSQLExceptionTranslator` 回退到 `SQLState` 内省。这通常足以满足常见的数据库访问需求，不需要特定于供应商的检测。为了向后兼容，请考虑如下所述使用 `SQLErrorCodeSQLExceptionTranslator`，可能带有自定义错误代码映射。

`SQLErrorCodeSQLExceptionTranslator` 是 `SQLExceptionTranslator` 的实现，当类路径的根目录中存在名为 `sql-error-codes.xml` 的文件时，默认使用该实现。此实现使用特定的供应商代码。它比 `SQLState` 或 `SQLException` 子类转换更精确。错误代码转换基于名为 `SQLErrorCodes` 的 JavaBean 类型类中保存的代码。此类由 `SQLErrorCodesFactory` 创建和填充，顾名思义，它是一个基于名为 `sql-error-codes.xml` 的配置文件的内容创建 `SQLErrorCodes` 的工厂。此文件填充了供应商代码，并基于从 `DatabaseMetaData` 获取的 `DatabaseProductName`。使用您正在使用的实际数据库的代码。

`SQLErrorCodeSQLExceptionTranslator` 按以下顺序应用匹配规则：

. 由子类实现的任何自定义转换。通常，使用提供的具体 `SQLErrorCodeSQLExceptionTranslator`，因此此规则不适用。它仅在您实际提供了子类实现时才适用。
. 作为 `SQLErrorCodes` 类的 `customSqlExceptionTranslator` 属性提供的 `SQLExceptionTranslator` 接口的任何自定义实现。
. 搜索 `CustomSQLErrorCodesTranslation` 类实例列表（为 `SQLErrorCodes` 类的 `customTranslations` 属性提供）以查找匹配项。
. 应用错误代码匹配。
. 使用回退转换器。`SQLExceptionSubclassTranslator` 是默认的回退转换器。如果此转换不可用，则下一个回退转换器是 `SQLStateSQLExceptionTranslator`。

NOTE: `SQLErrorCodesFactory` 默认用于定义错误代码和自定义异常转换。它们从类路径中名为 `sql-error-codes.xml` 的文件中查找，并且根据正在使用的数据库的数据库元数据中的数据库名称定位匹配的 `SQLErrorCodes` 实例。

您可以扩展 `SQLErrorCodeSQLExceptionTranslator`，如下例所示：

[tabs]
======
Java::
+
[source,java,indent=0,subs="verbatim,quotes",role="primary"]
----
public class CustomSQLErrorCodesTranslator extends SQLErrorCodeSQLExceptionTranslator {

  protected DataAccessException customTranslate(String task, String sql, SQLException sqlEx) {
    if (sqlEx.getErrorCode() == -12345) {
      return new DeadlockLoserDataAccessException(task, sqlEx);
    }
    return null;
  }
}
----

======

在前面的示例中，特定的错误代码 (`-12345`) 被转换，而其他错误则留给默认转换器实现进行转换。
要使用此自定义转换器，您必须通过 `setExceptionTranslator` 方法将其传递给 `JdbcTemplate`，并且您必须将此 `JdbcTemplate` 用于需要此转换器的所有数据访问处理。以下示例显示了如何使用此自定义转换器：

[tabs]
======
Java::
+
[source,java,indent=0,subs="verbatim,quotes",role="primary"]
----
private JdbcTemplate jdbcTemplate;

public void setDataSource(DataSource dataSource) {
  // 创建 JdbcTemplate 并设置数据源
  this.jdbcTemplate = new JdbcTemplate();
  this.jdbcTemplate.setDataSource(dataSource);

  // 创建自定义转换器并设置 DataSource 以进行默认转换查找
  CustomSQLErrorCodesTranslator tr = new CustomSQLErrorCodesTranslator();
  tr.setDataSource(dataSource);
  this.jdbcTemplate.setExceptionTranslator(tr);
}

public void updateShippingCharge(long orderId, long pct) {
  // 使用准备好的 JdbcTemplate 进行此更新
  this.jdbcTemplate.update("update orders" +
    " set shipping_charge = shipping_charge * ? / 100 where id = ?", pct, orderId);
}
----

======

自定义转换器被传递一个数据源，以便在 `sql-error-codes.xml` 中查找错误代码。


[[jdbc-statements-executing]]
== 运行语句

运行 SQL 语句只需要很少的代码。您需要一个 `DataSource` 和一个 `JdbcTemplate`，包括 `JdbcTemplate` 提供的便捷方法。以下示例显示了创建一个新表所需的最小但功能齐全的类中包含的内容：

[tabs]
======
Java::
+
[source,java,indent=0,subs="verbatim,quotes",role="primary"]
----
import javax.sql.DataSource;
import infra.jdbc.core.JdbcTemplate;

public class ExecuteAStatement {

  private JdbcTemplate jdbcTemplate;

  public void setDataSource(DataSource dataSource) {
    this.jdbcTemplate = new JdbcTemplate(dataSource);
  }

  public void doExecute() {
    this.jdbcTemplate.execute("create table mytable (id integer, name varchar(100))");
  }
}
----

======


[[jdbc-statements-querying]]
== 运行查询

一些查询方法返回单个值。要从一行中检索计数或特定值，请使用 `queryForObject(..)`。后者将返回的 JDBC `Type` 转换为作为参数传入的 Java 类。如果类型转换无效，则抛出 `InvalidDataAccessApiUsageException`。以下示例包含两个查询方法，一个用于 `int`，一个用于查询 `String`：

[tabs]
======
Java::
+
[source,java,indent=0,subs="verbatim,quotes",role="primary"]
----
import javax.sql.DataSource;
import infra.jdbc.core.JdbcTemplate;

public class RunAQuery {

  private JdbcTemplate jdbcTemplate;

  public void setDataSource(DataSource dataSource) {
    this.jdbcTemplate = new JdbcTemplate(dataSource);
  }

  public int getCount() {
    return this.jdbcTemplate.queryForObject("select count(*) from mytable", Integer.class);
  }

  public String getName() {
    return this.jdbcTemplate.queryForObject("select name from mytable", String.class);
  }
}
----

======

除了单个结果查询方法之外，还有几个方法返回一个列表，其中包含查询返回的每一行的条目。最通用的方法是 `queryForList(..)`，它返回一个 `List`，其中每个元素都是一个 `Map`，包含每列的一个条目，使用列名作为键。如果您向前面的示例添加一个方法以检索所有行的列表，它可能如下所示：

[tabs]
======
Java::
+
[source,java,indent=0,subs="verbatim,quotes",role="primary"]
----
private JdbcTemplate jdbcTemplate;

public void setDataSource(DataSource dataSource) {
  this.jdbcTemplate = new JdbcTemplate(dataSource);
}

public List<Map<String, Object>> getList() {
  return this.jdbcTemplate.queryForList("select * from mytable");
}
----

======

返回的列表将类似于以下内容：

[literal,subs="verbatim,quotes"]
----
[{name=Bob, id=1}, {name=Mary, id=2}]
----


[[jdbc-updates]]
== 更新数据库

以下示例更新某个主键的列：

[tabs]
======
Java::
+
[source,java,indent=0,subs="verbatim,quotes",role="primary"]
----
import javax.sql.DataSource;
import infra.jdbc.core.JdbcTemplate;

public class ExecuteAnUpdate {

  private JdbcTemplate jdbcTemplate;

  public void setDataSource(DataSource dataSource) {
    this.jdbcTemplate = new JdbcTemplate(dataSource);
  }

  public void setName(int id, String name) {
    this.jdbcTemplate.update("update mytable set name = ? where id = ?", name, id);
  }
}
----
======

在前面的示例中，SQL 语句具有行参数的占位符。您可以将参数值作为可变参数传入，或者作为对象数组传入。因此，您应该显式地将基元包装在基元包装类中，或者您应该使用自动装箱。


[[jdbc-auto-generated-keys]]
== 检索自动生成的键

`update()` 便捷方法支持检索由数据库生成的主键。此支持是 JDBC 3.0 标准的一部分。有关详细信息，请参阅规范的第 13.6 章。该方法将 `PreparedStatementCreator` 作为其第一个参数，这是指定所需插入语句的方式。另一个参数是 `KeyHolder`，它在更新成功返回时包含生成的键。没有标准的单一方法来创建适当的 `PreparedStatement`（这解释了为什么方法签名是这样的）。以下示例在 Oracle 上有效，但在其他平台上可能无效：

[tabs]
======
Java::
+
[source,java,indent=0,subs="verbatim,quotes",role="primary"]
----
final String INSERT_SQL = "insert into my_test (name) values(?)";
final String name = "Rob";

KeyHolder keyHolder = new GeneratedKeyHolder();
jdbcTemplate.update(connection -> {
  PreparedStatement ps = connection.prepareStatement(INSERT_SQL, new String[] { "id" });
  ps.setString(1, name);
  return ps;
}, keyHolder);

// keyHolder.getKey() 现在包含生成的键
----

======
