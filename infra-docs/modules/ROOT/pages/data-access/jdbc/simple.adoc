[[jdbc-simple-jdbc]]
= 使用 `SimpleJdbc` 类简化 JDBC 操作

`SimpleJdbcInsert` 和 `SimpleJdbcCall` 类通过利用可以通过 JDBC 驱动程序检索的数据库元数据来提供简化的配置。这意味着您前期需要配置的内容更少，尽管如果您更喜欢在代码中提供所有详细信息，您可以覆盖或关闭元数据处理。


[[jdbc-simple-jdbc-insert-1]]
== 使用 `SimpleJdbcInsert` 插入数据

我们首先查看具有最少配置选项的 `SimpleJdbcInsert` 类。您应该在数据访问层的初始化方法中实例化 `SimpleJdbcInsert`。对于此示例，初始化方法是 `setDataSource` 方法。您不需要子类化 `SimpleJdbcInsert` 类。相反，您可以创建一个新实例并使用 `withTableName` 方法设置表名。此类的配置方法遵循 `fluid` 风格，返回 `SimpleJdbcInsert` 的实例，这允许您链接所有配置方法。以下示例仅使用一种配置方法（稍后我们将展示多种方法的示例）：

[tabs]
======
Java::
+
[source,java,indent=0,subs="verbatim,quotes",role="primary"]
----
public class JdbcActorDao implements ActorDao {

  private SimpleJdbcInsert insertActor;

  public void setDataSource(DataSource dataSource) {
    this.insertActor = new SimpleJdbcInsert(dataSource).withTableName("t_actor");
  }

  public void add(Actor actor) {
    Map<String, Object> parameters = new HashMap<>(3);
    parameters.put("id", actor.getId());
    parameters.put("first_name", actor.getFirstName());
    parameters.put("last_name", actor.getLastName());
    insertActor.execute(parameters);
  }

  // ... additional methods
}
----

======

这里使用的 `execute` 方法采用普通的 `java.util.Map` 作为其唯一参数。这里需要注意的重要一点是，用于 `Map` 的键必须与数据库中定义的表列名匹配。这是因为我们读取元数据来构造实际的插入语句。


[[jdbc-simple-jdbc-insert-2]]
== 使用 `SimpleJdbcInsert` 检索自动生成的键

下一个示例使用与上一个示例相同的插入，但它不传入 `id`，而是检索自动生成的键并在新的 `Actor` 对象上设置它。当它创建 `SimpleJdbcInsert` 时，除了指定表名外，它还使用 `usingGeneratedKeyColumns` 方法指定生成的键列的名称。以下清单显示了它是如何工作的：

[tabs]
======
Java::
+
[source,java,indent=0,subs="verbatim,quotes",role="primary"]
----
public class JdbcActorDao implements ActorDao {

  private SimpleJdbcInsert insertActor;

  public void setDataSource(DataSource dataSource) {
    this.insertActor = new SimpleJdbcInsert(dataSource)
        .withTableName("t_actor")
        .usingGeneratedKeyColumns("id");
  }

  public void add(Actor actor) {
    Map<String, Object> parameters = new HashMap<>(2);
    parameters.put("first_name", actor.getFirstName());
    parameters.put("last_name", actor.getLastName());
    Number newId = insertActor.executeAndReturnKey(parameters);
    actor.setId(newId.longValue());
  }

  // ... additional methods
}
----
======

使用这第二种方法运行插入的主要区别在于，您不将 `id` 添加到 `Map` 中，而是调用 `executeAndReturnKey` 方法。这返回一个 `java.lang.Number` 对象，您可以使用该对象创建域类中使用的数字类型的实例。您不能依赖所有数据库都在此处返回特定的 Java 类。`java.lang.Number` 是您可以依赖的基类。如果您有多个自动生成的列，或者生成的值是非数字的，则可以使用从 `executeAndReturnKeyHolder` 方法返回的 `KeyHolder`。


[[jdbc-simple-jdbc-insert-3]]
== 为 `SimpleJdbcInsert` 指定列

您可以通过使用 `usingColumns` 方法指定列名列表来限制插入的列，如下例所示：

[tabs]
======
Java::
+
[source,java,indent=0,subs="verbatim,quotes",role="primary"]
----
public class JdbcActorDao implements ActorDao {

  private SimpleJdbcInsert insertActor;

  public void setDataSource(DataSource dataSource) {
    this.insertActor = new SimpleJdbcInsert(dataSource)
        .withTableName("t_actor")
        .usingColumns("first_name", "last_name")
        .usingGeneratedKeyColumns("id");
  }

  public void add(Actor actor) {
    Map<String, Object> parameters = new HashMap<>(2);
    parameters.put("first_name", actor.getFirstName());
    parameters.put("last_name", actor.getLastName());
    Number newId = insertActor.executeAndReturnKey(parameters);
    actor.setId(newId.longValue());
  }

  // ... additional methods
}
----

======

插入的执行与您依赖元数据确定要使用哪些列的情况相同。


[[jdbc-simple-jdbc-parameters]]
== 使用 `SqlParameterSource` 提供参数值

使用 `Map` 提供参数值效果很好，但它不是最方便使用的类。Infra 提供了 `SqlParameterSource` 接口的几个实现，您可以改用它们。第一个是 `BeanPropertySqlParameterSource`，如果您有一个包含值的符合 JavaBean 的类，那么这是一个非常方便的类。它使用相应的 getter 方法提取参数值。以下示例显示了如何使用 `BeanPropertySqlParameterSource`：

[tabs]
======
Java::
+
[source,java,indent=0,subs="verbatim,quotes",role="primary"]
----
public class JdbcActorDao implements ActorDao {

  private SimpleJdbcInsert insertActor;

  public void setDataSource(DataSource dataSource) {
    this.insertActor = new SimpleJdbcInsert(dataSource)
        .withTableName("t_actor")
        .usingGeneratedKeyColumns("id");
  }

  public void add(Actor actor) {
    SqlParameterSource parameters = new BeanPropertySqlParameterSource(actor);
    Number newId = insertActor.executeAndReturnKey(parameters);
    actor.setId(newId.longValue());
  }

  // ... additional methods
}
----

======

另一个选项是 `MapSqlParameterSource`，它类似于 `Map`，但提供了一个更方便的 `addValue` 方法，可以链接该方法。以下示例显示了如何使用它：

[tabs]
======
Java::
+
[source,java,indent=0,subs="verbatim,quotes",role="primary"]
----
public class JdbcActorDao implements ActorDao {

  private SimpleJdbcInsert insertActor;

  public void setDataSource(DataSource dataSource) {
    this.insertActor = new SimpleJdbcInsert(dataSource)
        .withTableName("t_actor")
        .usingGeneratedKeyColumns("id");
  }
