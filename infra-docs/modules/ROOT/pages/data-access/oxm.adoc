[[oxm]]
= 使用 Object-XML 映射器进行 XML 编组



[[oxm-introduction]]
== 简介

本章描述了 Infra Object-XML 映射支持。Object-XML 映射（简称 O-X 映射）是将 XML 文档转换为对象或将对象转换为 XML 文档的行为。此转换过程也称为 XML 编组（Marshalling）或 XML 序列化（Serialization）。本章可以互换使用这些术语。

在 O-X 映射领域，编组器（marshaller）负责将对象（图）序列化为 XML。同样，解组器（unmarshaller）将 XML 反序列化为对象图。此 XML 可以采用 DOM 文档、输入或输出流或 SAX 处理程序的形式。

使用 Infra 满足 O/X 映射需求的一些好处包括：

* xref:data-access/oxm.adoc#oxm-ease-of-configuration[易于配置]
* xref:data-access/oxm.adoc#oxm-consistent-interfaces[一致的接口]
* xref:data-access/oxm.adoc#oxm-consistent-exception-hierarchy[一致的异常层次结构]


[[oxm-ease-of-configuration]]
=== 易于配置

Infra bean 工厂使配置编组器变得容易，无需构建 JAXB 上下文、JiBX 绑定工厂等。您可以像配置应用程序上下文中的任何其他 bean 一样配置编组器。此外，基于 XML 命名空间的配置可用于多种编组器，使配置更加简单。


[[oxm-consistent-interfaces]]
=== 一致的接口

Infra O-X 映射通过两个全局接口运行：{today-framework-api}/oxm/Marshaller.html[`Marshaller`] 和 {today-framework-api}/oxm/Unmarshaller.html[`Unmarshaller`]。这些抽象使您可以相对轻松地切换 O-X 映射框架，而无需对执行编组的类进行任何更改或只需很少的更改。这种方法的另一个好处是，可以以非侵入式方式使用混合搭配的方法进行 XML 编组（例如，一些编组使用 JAXB 执行，另一些使用 XStream 执行），让您利用每种技术的优势。


[[oxm-consistent-exception-hierarchy]]
=== 一致的异常层次结构

Infra 提供了从底层 O-X 映射工具的异常到其自己的异常层次结构的转换，其中 `XmlMappingException` 作为根异常。这些运行时异常包装了原始异常，因此不会丢失任何信息。



[[oxm-marshaller-unmarshaller]]
== `Marshaller` 和 `Unmarshaller`

如 xref:data-access/oxm.adoc#oxm-introduction[简介] 中所述，编组器将对象序列化为 XML，解组器将 XML 流反序列化为对象。本节描述用于此目的的两个 Infra 接口。


[[oxm-marshaller]]
=== 理解 `Marshaller`

Infra 将所有编组操作抽象在 `infra.oxm.Marshaller` 接口之后，其主要方法如下：

[source,java,indent=0,subs="verbatim,quotes"]
----
public interface Marshaller {

  /**
   * 将具有给定根的对象图编组到提供的 Result 中。
   */
  void marshal(Object graph, Result result) throws XmlMappingException, IOException;
}
----

`Marshaller` 接口有一个主要方法，该方法将给定的对象编组到给定的 `javax.xml.transform.Result`。Result 是一个标记接口，基本上代表了 XML 输出抽象。具体实现包装了各种 XML 表示形式，如下表所示：

[[oxm-marshaller-tbl]]
|===
| Result 实现| 包装的 XML 表示形式

| `DOMResult`
| `org.w3c.dom.Node`

| `SAXResult`
| `org.xml.sax.ContentHandler`

| `StreamResult`
| `java.io.File`、`java.io.OutputStream` 或 `java.io.Writer`
|===

NOTE: 虽然 `marshal()` 方法接受一个普通对象作为其第一个参数，但大多数 `Marshaller` 实现无法处理任意对象。相反，对象类必须在映射文件中映射、使用注解标记、向编组器注册或具有公共基类。请参阅本章后面的部分，以确定您的 O-X 技术如何管理这一点。


[[oxm-unmarshaller]]
=== 理解 `Unmarshaller`

与 `Marshaller` 类似，我们有 `infra.oxm.Unmarshaller` 接口，如下表所示：

[source,java,indent=0,subs="verbatim,quotes"]
----
public interface Unmarshaller {

  /**
   * 将给定的提供的 Source 解组为对象图。
   */
  Object unmarshal(Source source) throws XmlMappingException, IOException;
}
----

此接口也有一个方法，该方法从给定的 `javax.xml.transform.Source`（XML 输入抽象）读取并返回读取的对象。与 `Result` 一样，`Source` 是一个标记接口，具有三个具体实现。每个都包装了不同的 XML 表示形式，如下表所示：

[[oxm-unmarshaller-tbl]]
|===
| Source 实现| 包装的 XML 表示形式

| `DOMSource`
| `org.w3c.dom.Node`

| `SAXSource`
| `org.xml.sax.InputSource` 和 `org.xml.sax.XMLReader`

| `StreamSource`
| `java.io.File`、`java.io.InputStream` 或 `java.io.Reader`
|===

即使有两个单独的编组接口（`Marshaller` 和 `Unmarshaller`），Infra-WS 中的所有实现都在一个类中实现了这两个接口。这意味着您可以连接一个编组器类，并在 `applicationContext.xml` 中将其既作为编组器又作为解组器引用。


[[oxm-xmlmappingexception]]
=== 理解 `XmlMappingException`

Infra 提供了从底层 O-X 映射工具的异常到其自己的异常层次结构的转换，其中 `XmlMappingException` 作为根异常。这些运行时异常包装了原始异常，因此不会丢失任何信息。

此外，`MarshallingFailureException` 和 `UnmarshallingFailureException` 提供了编组和解组操作之间的区别，即使底层 O-X 映射工具没有这样做。

O-X 映射异常层次结构如下图所示：

image::oxm-exceptions.png[]



[[oxm-usage]]
== 使用 `Marshaller` 和 `Unmarshaller`

您可以将 Infra OXM 用于各种情况。在以下示例中，我们使用它将 Infra 管理的应用程序的设置编组为 XML 文件。在以下示例中，我们使用一个简单的 JavaBean 来表示设置：

[tabs]
======
Java::
+
[source,java,indent=0,subs="verbatim,quotes",role="primary"]
----
public class Settings {

  private boolean fooEnabled;

  public boolean isFooEnabled() {
    return fooEnabled;
  }

  public void setFooEnabled(boolean fooEnabled) {
    this.fooEnabled = fooEnabled;
  }
}
----

======

应用程序类使用此 bean 来存储其设置。除了 main 方法外，该类还有两个方法：`saveSettings()` 将设置 bean 保存到名为 `settings.xml` 的文件中，而 `loadSettings()` 再次加载这些设置。以下 `main()` 方法构造一个 Infra 应用程序上下文并调用这两个方法：
