[[transaction-programmatic]]
= 编程式事务管理

TODAY Framework 提供了两种编程式事务管理方法：

* 使用 `TransactionTemplate` 或 `TransactionalOperator`。
* 直接使用 `TransactionManager` 实现。

Infra 团队通常建议将 `TransactionTemplate` 用于命令式流程中的编程式事务管理，将 `TransactionalOperator` 用于响应式代码。第二种方法类似于使用 JTA `UserTransaction` API，尽管异常处理不那么繁琐。


[[tx-prog-template]]
== 使用 `TransactionTemplate`

`TransactionTemplate` 采用与其他 Infra 模板（如 `JdbcTemplate`）相同的方法。它使用回调方法（使应用程序代码免于执行样板式获取和释放事务资源），从而产生意图驱动的代码，即您的代码仅关注您想要做的事情。

NOTE: 如下面的示例所示，使用 `TransactionTemplate` 绝对会将您耦合到 Infra 事务基础设施和 API。编程式事务管理是否适合您的开发需求是您必须自己做出的决定。

必须在事务上下文中运行并显式使用 `TransactionTemplate` 的应用程序代码类似于下一个示例。作为应用程序开发人员，您可以编写一个 `TransactionCallback` 实现（通常表示为匿名内部类），其中包含您需要在事务上下文中运行的代码。然后，您可以将自定义 `TransactionCallback` 的实例传递给 `TransactionTemplate` 上公开的 `execute(..)` 方法。以下示例显示了如何执行此操作：

[tabs]
======
Java::
+
[source,java,indent=0,subs="verbatim,quotes",role="primary"]
----
public class SimpleService implements Service {

  // 在此实例的所有方法之间共享的单个 TransactionTemplate
  private final TransactionTemplate transactionTemplate;

  // 使用构造函数注入来提供 PlatformTransactionManager
  public SimpleService(PlatformTransactionManager transactionManager) {
    this.transactionTemplate = new TransactionTemplate(transactionManager);
  }

  public Object someServiceMethod() {
    return transactionTemplate.execute(new TransactionCallback() {
      // 此方法中的代码在事务上下文中运行
      public Object doInTransaction(TransactionStatus status) {
        updateOperation1();
        return resultOfUpdateOperation2();
      }
    });
  }
}
----

======


如果没有返回值，您可以将方便的 `TransactionCallbackWithoutResult` 类与匿名类一起使用，如下所示：

[tabs]
======
Java::
+
[source,java,indent=0,subs="verbatim,quotes",role="primary"]
----
transactionTemplate.execute(new TransactionCallbackWithoutResult() {
  protected void doInTransactionWithoutResult(TransactionStatus status) {
    updateOperation1();
    updateOperation2();
  }
});
----

======


回调中的代码可以通过在提供的 `TransactionStatus` 对象上调用 `setRollbackOnly()` 方法来回滚事务，如下所示：

[tabs]
======
Java::
+
[source,java,indent=0,subs="verbatim,quotes",role="primary"]
----
  transactionTemplate.execute(new TransactionCallbackWithoutResult() {

    protected void doInTransactionWithoutResult(TransactionStatus status) {
      try {
        updateOperation1();
        updateOperation2();
      } catch (SomeBusinessException ex) {
        status.setRollbackOnly();
      }
    }
  });
----

======

[[tx-prog-template-settings]]
=== 指定事务设置

您可以通过编程方式或在配置中指定 `TransactionTemplate` 上的事务设置（例如传播模式、隔离级别、超时等）。默认情况下，`TransactionTemplate` 实例具有 xref:data-access/transaction/declarative/txadvice-settings.adoc[默认事务设置]。以下示例显示了特定 `TransactionTemplate` 的事务设置的编程式自定义：

[tabs]
======
Java::
+
[source,java,indent=0,subs="verbatim,quotes",role="primary"]
----
public class SimpleService implements Service {

  private final TransactionTemplate transactionTemplate;

  public SimpleService(PlatformTransactionManager transactionManager) {
    this.transactionTemplate = new TransactionTemplate(transactionManager);

    // 如果需要，可以在此处显式设置事务设置
    this.transactionTemplate.setIsolationLevel(TransactionDefinition.ISOLATION_READ_UNCOMMITTED);
    this.transactionTemplate.setTimeout(30); // 30 seconds
    // 等等...
  }
}
----

======

以下示例使用 Infra XML 配置定义具有一些自定义事务设置的 `TransactionTemplate`：

[source,xml,indent=0,subs="verbatim,quotes"]
----
<bean id="sharedTransactionTemplate"
    class="infra.transaction.support.TransactionTemplate">
  <property name="isolationLevelName" value="ISOLATION_READ_UNCOMMITTED"/>
  <property name="timeout" value="30"/>
</bean>
----

然后，您可以将 `sharedTransactionTemplate` 注入到所需的任意数量的服务中。

最后，`TransactionTemplate` 类的实例是线程安全的，因为实例不维护任何会话状态。但是，`TransactionTemplate` 实例确实维护配置状态。因此，虽然许多类可以共享 `TransactionTemplate` 的单个实例，但如果一个类需要使用具有不同设置（例如，不同的隔离级别）的 `TransactionTemplate`，则需要创建两个不同的 `TransactionTemplate` 实例。

[[tx-prog-operator]]
== 使用 `TransactionalOperator`

`TransactionalOperator` 遵循与其他响应式操作符类似的操作符设计。它使用回调方法（使应用程序代码免于执行样板式获取和释放事务资源），从而产生意图驱动的代码，即您的代码仅关注您想要做的事情。

NOTE: 如下面的示例所示，使用 `TransactionalOperator` 绝对会将您耦合到 Infra 事务基础设施和 API。编程式事务管理是否适合您的开发需求是您必须自己做出的决定。

必须在事务上下文中运行并显式使用 `TransactionalOperator` 的应用程序代码类似于下一个示例：

[tabs]
======
Java::
+
[source,java,indent=0,subs="verbatim,quotes",role="primary"]
----
public class SimpleService implements Service {

  // 在此实例的所有方法之间共享的单个 TransactionalOperator
  private final TransactionalOperator transactionalOperator;

  // 使用构造函数注入来提供 ReactiveTransactionManager
  public SimpleService(ReactiveTransactionManager transactionManager) {
    this.transactionalOperator = TransactionalOperator.create(transactionManager);
  }

  public Mono<Object> someServiceMethod() {

    // 此方法中的代码在事务上下文中运行
