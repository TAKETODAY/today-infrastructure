[[transaction-declarative-rolling-back]]
= 回滚声明式事务

上一节概述了如何在应用程序中以声明方式为类（通常是服务层类）指定事务设置的基础知识。本节描述如何以 XML 配置中简单、声明式的方式控制事务的回滚。有关使用 `@Transactional` 注解以声明方式控制回滚语义的详细信息，请参阅 xref:data-access/transaction/declarative/annotations.adoc#transaction-declarative-attransactional-settings[`@Transactional` 设置]。

向 TODAY Framework 的事务基础设施指示事务工作要回滚的推荐方法是从当前在事务上下文中执行的代码中抛出 `Exception`。TODAY Framework 的事务基础设施代码会捕获任何未处理的 `Exception`，因为它会冒泡调用堆栈，并确定是否将事务标记为回滚。

在其默认配置中，TODAY Framework 的事务基础设施代码仅在运行时、未检查异常的情况下将事务标记为回滚。也就是说，当抛出的异常是 `RuntimeException` 的实例或子类时。（默认情况下，`Error` 实例也会导致回滚）。

从事务方法抛出的检查异常在默认配置中不会导致回滚。您可以通过指定 _回滚规则_ 来确切配置哪些 `Exception` 类型将事务标记为回滚，包括检查异常。

.回滚规则
[[transaction-declarative-rollback-rules]]
[NOTE]
====
回滚规则确定当抛出给定异常时是否应回滚事务，规则基于异常类型或异常模式。

回滚规则可以通过 `rollback-for` 和 `no-rollback-for` 属性在 XML 中配置，这允许将规则定义为模式。当使用 xref:data-access/transaction/declarative/annotations.adoc#transaction-declarative-attransactional-settings[`@Transactional`] 时，可以通过 `rollbackFor`/`noRollbackFor` 和 `rollbackForClassName`/`noRollbackForClassName` 属性配置回滚规则，这分别允许基于异常类型或模式定义规则。

当使用异常类型定义回滚规则时，该类型将用于匹配抛出的异常及其超类型的类型，从而提供类型安全性并避免在使用模式时可能发生的任何意外匹配。例如，`jakarta.mockApi.ServletException.class` 的值将仅匹配 `jakarta.mockApi.ServletException` 及其子类型的抛出异常。

当使用异常模式定义回滚规则时，模式可以是完全限定的类名或异常类型（必须是 `Throwable` 的子类）的完全限定类名的子字符串，目前不支持通配符。例如，`"jakarta.mockApi.ServletException"` 或 `"ServletException"` 的值将匹配 `jakarta.mockApi.ServletException` 及其子类。

[WARNING]
=====
您必须仔细考虑模式的具体程度以及是否包含包信息（这不是强制性的）。例如，`"Exception"` 将匹配几乎任何内容，并且可能会隐藏其他规则。如果 `"Exception"` 旨在为所有检查异常定义规则，则 `"java.lang.Exception"` 将是正确的。对于更独特的异常名称，例如 `"BaseBusinessException"`，可能不需要对异常模式使用完全限定的类名。

此外，基于模式的回滚规则可能会导致名称相似的异常和嵌套类的意外匹配。这是因为如果抛出的异常的名称包含为回滚规则配置的异常模式，则认为抛出的异常与给定的基于模式的回滚规则匹配。例如，给定配置为匹配 `"com.example.CustomException"` 的规则，该规则将匹配名为 `com.example.CustomExceptionV2` 的异常（与 `CustomException` 在同一包中但具有附加后缀的异常）或名为 `com.example.CustomException$AnotherException` 的异常（在 `CustomException` 中声明为嵌套类的异常）。
=====
====

以下 XML 代码片段演示了如何通过 `rollback-for` 属性提供 _异常模式_ 来为已检查的、特定于应用程序的 `Exception` 类型配置回滚：

[source,xml,indent=0,subs="verbatim,quotes"]
----
<tx:advice id="txAdvice" transaction-manager="txManager">
  <tx:attributes>
    <tx:method name="get*" read-only="true" rollback-for="NoProductInStockException"/>
    <tx:method name="*"/>
  </tx:attributes>
</tx:advice>
----

如果您不希望在抛出异常时回滚事务，您还可以指定“不回滚”规则。以下示例告诉 TODAY Framework 的事务基础设施即使面对未处理的 `InstrumentNotFoundException` 也要提交伴随的事务：

[source,xml,indent=0,subs="verbatim,quotes"]
----
<tx:advice id="txAdvice">
  <tx:attributes>
    <tx:method name="updateStock" no-rollback-for="InstrumentNotFoundException"/>
    <tx:method name="*"/>
  </tx:attributes>
</tx:advice>
----

当 TODAY Framework 的事务基础设施捕获异常并咨询配置的回滚规则以确定是否将事务标记为回滚时，最强的匹配规则获胜。因此，在以下配置的情况下，除 `InstrumentNotFoundException` 之外的任何异常都会导致伴随事务的回滚：

[source,xml,indent=0,subs="verbatim,quotes"]
----
<tx:advice id="txAdvice">
  <tx:attributes>
    <tx:method name="*" rollback-for="Throwable" no-rollback-for="InstrumentNotFoundException"/>
  </tx:attributes>
</tx:advice>
----

您还可以以编程方式指示所需的回滚。虽然很简单，但此过程具有很强的侵入性，并且将您的代码紧密耦合到 TODAY Framework 的事务基础设施。以下示例显示了如何以编程方式指示所需的回滚：

[tabs]
======
Java::
+
[source,java,indent=0,subs="verbatim,quotes",role="primary"]
----
public void resolvePosition() {
  try {
    // 一些业务逻辑...
  } catch (NoProductInStockException ex) {
    // 以编程方式触发回滚
    TransactionAspectSupport.currentTransactionStatus().setRollbackOnly();
  }
}
----

======

强烈建议您尽可能使用声明式方法进行回滚。如果您绝对需要，可以使用编程式回滚，但它的使用与实现干净的基于 POJO 的架构背道而驰。
