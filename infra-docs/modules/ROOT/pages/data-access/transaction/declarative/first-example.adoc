[[transaction-declarative-first-example]]
= 声明式事务实现示例

考虑以下接口及其附带的实现。此示例使用 `Foo` 和 `Bar` 类作为占位符，以便您可以专注于事务使用，而无需关注特定的域模型。就本示例而言，`DefaultFooService` 类在每个实现的方法主体中抛出 `UnsupportedOperationException` 实例是件好事。该行为让您看到事务被创建，然后响应 `UnsupportedOperationException` 实例而回滚。以下清单显示了 `FooService` 接口：

[tabs]
======
Java::
+
[source,java,indent=0,subs="verbatim,quotes",role="primary",chomp="-packages"]
----
// 我们想要使其具有事务性的服务接口

package x.y.service;

public interface FooService {

  Foo getFoo(String fooName);

  Foo getFoo(String fooName, String barName);

  void insertFoo(Foo foo);

  void updateFoo(Foo foo);

}
----

======

以下示例显示了前面接口的实现：

[tabs]
======
Java::
+
[source,java,indent=0,subs="verbatim,quotes",role="primary",chomp="-packages"]
----
package x.y.service;

public class DefaultFooService implements FooService {

  @Override
  public Foo getFoo(String fooName) {
    // ...
  }

  @Override
  public Foo getFoo(String fooName, String barName) {
    // ...
  }

  @Override
  public void insertFoo(Foo foo) {
    // ...
  }

  @Override
  public void updateFoo(Foo foo) {
    // ...
  }
}
----

======

假设 `FooService` 接口的前两个方法 `getFoo(String)` 和 `getFoo(String, String)` 必须在具有只读语义的事务上下文中运行，而其他方法 `insertFoo(Foo)` 和 `updateFoo(Foo)` 必须在具有读写语义的事务上下文中运行。以下配置在接下来的几段中详细解释：

[source,xml,indent=0,subs="verbatim"]
----
<!-- 来自文件 'context.xml' -->
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xmlns:aop="http://www.springframework.org/schema/aop"
  xmlns:tx="http://www.springframework.org/schema/tx"
  xsi:schemaLocation="
    http://www.springframework.org/schema/beans
    https://www.springframework.org/schema/beans/spring-beans.xsd
    http://www.springframework.org/schema/tx
    https://www.springframework.org/schema/tx/spring-tx.xsd
    http://www.springframework.org/schema/aop
    https://www.springframework.org/schema/aop/spring-aop.xsd">

  <!-- 这是我们想要使其具有事务性的服务对象 -->
  <bean id="fooService" class="x.y.service.DefaultFooService"/>

  <!-- 事务通知（'发生'什么；参见下面的 <aop:advisor/> bean） -->
  <tx:advice id="txAdvice" transaction-manager="txManager">
    <!-- 事务语义... -->
    <tx:attributes>
      <!-- 所有以 'get' 开头的方法都是只读的 -->
      <tx:method name="get*" read-only="true"/>
      <!-- 其他方法使用默认事务设置（见下文） -->
      <tx:method name="*"/>
    </tx:attributes>
  </tx:advice>

  <!-- 确保上述事务通知针对 FooService 接口定义的任何操作执行运行 -->
  <aop:config>
    <aop:pointcut id="fooServiceOperation" expression="execution(* x.y.service.FooService.*(..))"/>
    <aop:advisor advice-ref="txAdvice" pointcut-ref="fooServiceOperation"/>
  </aop:config>

  <!-- 别忘了 DataSource -->
  <bean id="dataSource" class="org.apache.commons.dbcp.BasicDataSource" destroy-method="close">
    <property name="driverClassName" value="oracle.jdbc.driver.OracleDriver"/>
    <property name="url" value="jdbc:oracle:thin:@rj-t42:1521:elvis"/>
    <property name="username" value="scott"/>
    <property name="password" value="tiger"/>
  </bean>

  <!-- 同样，别忘了 TransactionManager -->
  <bean id="txManager" class="infra.jdbc.datasource.DataSourceTransactionManager">
    <property name="dataSource" ref="dataSource"/>
  </bean>

  <!-- 其他 <bean/> 定义在这里 -->

</beans>
----

检查前面的配置。它假设您想使服务对象 `fooService` bean 具有事务性。要应用的事务语义封装在 `<tx:advice/>` 定义中。`<tx:advice/>` 定义读作“所有以 `get` 开头的方法都在只读事务的上下文中运行，所有其他方法都以默认事务语义运行”。`<tx:advice/>` 标签的 `transaction-manager` 属性设置为将驱动事务的 `TransactionManager` bean 的名称（在本例中为 `txManager` bean）。

TIP: 如果您要连接的 `TransactionManager` 的 bean 名称为 `transactionManager`，则可以省略事务通知 (`<tx:advice/>`) 中的 `transaction-manager` 属性。如果您要连接的 `TransactionManager` bean 具有任何其他名称，则必须显式使用 `transaction-manager` 属性，如前面的示例所示。

`<aop:config/>` 定义确保由 `txAdvice` bean 定义的事务通知在程序中的适当点运行。首先，您定义一个切入点，该切入点匹配 `FooService` 接口中定义的任何操作的执行（`fooServiceOperation`）。然后，您使用 advisor 将切入点与 `txAdvice` 关联起来。结果表明，在执行 `fooServiceOperation` 时，将运行 `txAdvice` 定义的通知。

`<aop:pointcut/>` 元素中定义的表达式是 AspectJ 切入点表达式。有关 Infra 中切入点表达式的更多详细信息，请参阅 xref:core/aop.adoc[AOP 部分]。

一个常见的要求是使整个服务层具有事务性。执行此操作的最佳方法是更改切入点表达式以匹配服务层中的任何操作。以下示例显示了如何执行此操作：

[source,xml,indent=0,subs="verbatim"]
----
<aop:config>
  <aop:pointcut id="fooServiceMethods" expression="execution(* x.y.service.*.*(..))"/>
  <aop:advisor advice-ref="txAdvice" pointcut-ref="fooServiceMethods"/>
</aop:config>
----

NOTE: 在前面的示例中，假设您的所有服务接口都在 `x.y.service` 包中定义。有关更多详细信息，请参阅 xref:core/aop.adoc[AOP 部分]。

既然我们已经分析了配置，您可能会问自己，“所有这些配置实际上做了什么？”

前面显示的配置用于围绕从 `fooService` bean 定义创建的对象创建事务代理。代理配置了事务通知，以便在代理上调用适当的方法时，根据与该方法关联的事务配置，启动、挂起、标记为只读等事务。考虑以下测试驱动前面显示的配置的程序：

[tabs]
======
Java::
+
[source,java,indent=0,subs="verbatim,quotes",role="primary"]
----
public final class Boot {

  public static void main(final String[] args) throws Exception {
    ApplicationContext ctx = new ClassPathXmlApplicationContext("context.xml");
    FooService fooService = ctx.getBean(FooService.class);
    fooService.insertFoo(new Foo());
  }
}
----
