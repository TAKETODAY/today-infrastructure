[[transaction-declarative-annotations]]
= 使用 `@Transactional`

除了基于 XML 的声明式事务配置方法之外，您还可以使用基于注解的方法。直接在 Java 源代码中声明事务语义使声明更接近受影响的代码。不存在过度耦合的危险，因为无论如何，旨在以事务方式使用的代码几乎总是以这种方式部署的。

NOTE: 标准的 `jakarta.transaction.Transactional` 注解也支持作为 Infra 自身注解的直接替代品。请参阅 JTA 文档以获取更多详细信息。

使用 `@Transactional` 注解所提供的易用性最好通过一个示例来说明，该示例将在下文中解释。
考虑以下类定义：

[tabs]
======
Java::
+
[source,java,indent=0,subs="verbatim,quotes",role="primary"]
----
// 我们想要使其具有事务性的服务类
@Transactional
public class DefaultFooService implements FooService {

  @Override
  public Foo getFoo(String fooName) {
    // ...
  }

  @Override
  public Foo getFoo(String fooName, String barName) {
    // ...
  }

  @Override
  public void insertFoo(Foo foo) {
    // ...
  }

  @Override
  public void updateFoo(Foo foo) {
    // ...
  }
}
----

======

如上所述在类级别使用时，该注解表示声明类（及其子类）的所有方法的默认值。或者，可以单独注解每个方法。有关 Infra 认为哪些方法具有事务性的更多详细信息，请参阅 xref:data-access/transaction/declarative/annotations.adoc#transaction-declarative-annotations-method-visibility[方法可见性]。请注意，类级别的注解不适用于类层次结构中的祖先类；在这种情况下，需要在本地重新声明继承的方法，以便参与子类级别的注解。

当像上面这样的 POJO 类在 Infra 上下文中定义为 bean 时，您可以通过 `@Configuration` 类中的 `@EnableTransactionManagement` 注解使 bean 实例具有事务性。有关完整的详细信息，请参阅 {today-framework-api}/transaction/annotation/EnableTransactionManagement.html[javadoc]。

在 XML 配置中，`<tx:annotation-driven/>` 标签提供了类似的便利：

[source,xml,indent=0,subs="verbatim,quotes"]
----
<!-- 来自文件 'context.xml' -->
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xmlns:aop="http://www.springframework.org/schema/aop"
  xmlns:tx="http://www.springframework.org/schema/tx"
  xsi:schemaLocation="
    http://www.springframework.org/schema/beans
    https://www.springframework.org/schema/beans/spring-beans.xsd
    http://www.springframework.org/schema/tx
    https://www.springframework.org/schema/tx/spring-tx.xsd
    http://www.springframework.org/schema/aop
    https://www.springframework.org/schema/aop/spring-aop.xsd">

  <!-- 这是我们想要使其具有事务性的服务对象 -->
  <bean id="fooService" class="x.y.service.DefaultFooService"/>

  <!-- 启用基于注解的事务行为配置 -->
  <!-- 仍然需要 TransactionManager -->
  <tx:annotation-driven transaction-manager="txManager"/> <1>

  <bean id="txManager" class="infra.jdbc.datasource.DataSourceTransactionManager">
    <!-- (此依赖项在其他地方定义) -->
    <property name="dataSource" ref="dataSource"/>
  </bean>

  <!-- 其他 <bean/> 定义在这里 -->

</beans>
----
<1> 使 bean 实例具有事务性的行。

TIP: 如果您要连接的 `TransactionManager` 的 bean 名称为 `transactionManager`，则可以省略 `<tx:annotation-driven/>` 标签中的 `transaction-manager` 属性。如果您要依赖注入的 `TransactionManager` bean 具有任何其他名称，则必须使用 `transaction-manager` 属性，如前面的示例所示。

响应式事务方法使用响应式返回类型，与命令式编程安排形成对比，如下表所示：

[tabs]
======
Java::
+
[source,java,indent=0,subs="verbatim,quotes",role="primary"]
----
// 我们想要使其具有事务性的响应式服务类
@Transactional
public class DefaultFooService implements FooService {

  @Override
  public Publisher<Foo> getFoo(String fooName) {
    // ...
  }

  @Override
  public Mono<Foo> getFoo(String fooName, String barName) {
    // ...
  }

  @Override
  public Mono<Void> insertFoo(Foo foo) {
    // ...
  }

  @Override
  public Mono<Void> updateFoo(Foo foo) {
    // ...
  }
}
----

======

请注意，对于返回的 `Publisher`，在 Reactive Streams 取消信号方面有一些特殊的注意事项。有关更多详细信息，请参阅“使用 TransactionalOperator”下的 xref:data-access/transaction/programmatic.adoc#tx-prog-operator-cancel[取消信号] 部分。

[[transaction-declarative-annotations-method-visibility]]
.代理模式下的方法可见性和 `@Transactional`
[NOTE]
====
`@Transactional` 注解通常用于具有 `public` 可见性的方法。
从 6.0 开始，对于基于类的代理，`protected` 或包可见的方法默认情况下也可以是事务性的。请注意，基于接口的代理中的事务方法必须始终是 `public` 的，并且在代理接口中定义。对于这两种类型的代理，仅拦截通过代理进来的外部方法调用。

如果您更喜欢跨不同类型的代理对方法可见性进行一致的处理（这是直到 5.3 的默认设置），请考虑指定 `publicMethodsOnly`：

[source,java,indent=0,subs="verbatim,quotes"]
----
  /**
   * 注册一个自定义 AnnotationTransactionAttributeSource，
   * 并将 publicMethodsOnly 标志设置为 true，以一致地忽略非公共方法。
   * @see ProxyTransactionManagementConfiguration#transactionAttributeSource()
   */
  @Bean
  TransactionAttributeSource transactionAttributeSource() {
    return new AnnotationTransactionAttributeSource(true);
  }
----

_Infra TestContext Framework_ 默认也支持非私有的 `@Transactional` 测试方法。有关示例，请参阅测试章节中的 xref:testing/testcontext-framework/tx.adoc[事务管理]。
====

您可以将 `@Transactional` 注解应用于接口定义、接口上的方法、类定义或类上的方法。但是，仅仅存在 `@Transactional` 注解并不足以激活事务行为。`@Transactional` 注解仅仅是可以被相应的运行时基础设施使用的元数据，该基础设施使用该元数据来配置具有事务行为的适当 bean。在前面的示例中，`<tx:annotation-driven/>` 元素在运行时开启实际的事务管理。

TIP: Infra 团队建议您使用 `@Transactional` 注解具体类的方法，而不是依赖于接口中的注解方法，即使后者从 5.0 开始适用于基于接口和目标类的代理。由于 Java 注解不从接口继承，因此在使用 AspectJ 模式时，编织基础设施仍无法识别接口声明的注解，因此不会应用切面。结果，您的事务注解可能会被静默忽略：在您测试回滚场景之前，您的代码可能看起来“工作正常”。

NOTE: 在代理模式（默认模式）下，仅拦截通过代理进来的外部方法调用。这意味着即使调用的方法标记为 `@Transactional`，自调用（实际上是目标对象内的方法调用目标对象的另一个方法）也不会导致运行时的实际事务。此外，
