[[tx-decl-explained]]
= 理解 TODAY Framework 的声明式事务实现

仅仅告诉您用 `@Transactional` 注解来注解您的类，将 `@EnableTransactionManagement` 添加到您的配置中，并期望您了解这一切是如何工作的，这还不够。为了提供更深入的理解，本节在事务相关问题的背景下解释了 TODAY Framework 声明式事务基础设施的内部工作原理。

关于 TODAY Framework 的声明式事务支持，要掌握的最重要概念是，此支持是 xref:core/aop/proxying.adoc#aop-understanding-aop-proxies[通过 AOP 代理] 启用的，并且事务通知是由元数据（目前基于 XML 或注解）驱动的。AOP 与事务元数据的组合产生了一个 AOP 代理，该代理使用 `TransactionInterceptor` 与适当的 `TransactionManager` 实现相结合，以围绕方法调用驱动事务。

NOTE: Infra AOP 在 xref:core/aop.adoc[AOP 部分] 中介绍。

TODAY Framework 的 `TransactionInterceptor` 为命令式和响应式编程模型提供事务管理。拦截器通过检查方法返回类型来检测所需的事务管理风格。返回响应式类型（如 `Publisher` 或 Kotlin `Flow`（或其子类型））的方法有资格进行响应式事务管理。包括 `void` 在内的所有其他返回类型都使用命令式事务管理的代码路径。

事务管理风格会影响所需的事务管理器。命令式事务需要 `PlatformTransactionManager`，而响应式事务使用 `ReactiveTransactionManager` 实现。

[NOTE]
====
`@Transactional` 通常与由 `PlatformTransactionManager` 管理的线程绑定事务一起使用，将事务暴露给当前执行线程内的所有数据访问操作。注意：这 _不会_ 传播到方法内新启动的线程。

由 `ReactiveTransactionManager` 管理的响应式事务使用 Reactor 上下文而不是线程局部属性。因此，所有参与的数据访问操作都需要在同一响应式管道中的同一 Reactor 上下文中执行。

当配置有 `ReactiveTransactionManager` 时，所有事务划分的方法都应返回响应式管道。Void 方法或常规返回类型需要与常规 `PlatformTransactionManager` 关联，例如通过相应 `@Transactional` 声明的 `transactionManager` 属性。
====

下图显示了在事务代理上调用方法的概念视图：

image::tx.png[]
