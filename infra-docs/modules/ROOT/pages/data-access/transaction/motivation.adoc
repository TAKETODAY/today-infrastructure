[[transaction-motivation]]
= TODAY Framework 事务支持模型的优势

传统上，EE 应用程序开发人员在事务管理方面有两种选择：全局事务或本地事务，但这两种选择都有深刻的局限性。接下来的两节将回顾全局和本地事务管理，然后讨论 TODAY Framework 的事务管理支持如何解决全局和本地事务模型的局限性。


[[transaction-global]]
== 全局事务

全局事务允许您使用多个事务资源，通常是关系数据库和消息队列。应用服务器通过 JTA 管理全局事务，JTA 是一个繁琐的 API（部分原因是其异常模型）。此外，JTA `UserTransaction` 通常需要从 JNDI 获取，这意味着您还需要使用 JNDI 才能使用 JTA。全局事务的使用限制了应用程序代码的任何潜在重用，因为 JTA 通常仅在应用服务器环境中可用。

以前，使用全局事务的首选方式是通过 EJB CMT（容器管理事务）。CMT 是一种声明式事务管理形式（与编程式事务管理相区别）。EJB CMT 消除了与事务相关的 JNDI 查找的需要，尽管使用 EJB 本身需要使用 JNDI。它消除了大部分（但不是全部）编写 Java 代码来控制事务的需要。显着的缺点是 CMT 绑定到 JTA 和应用服务器环境。此外，只有当选择在 EJB 中（或至少在事务性 EJB 外观之后）实现业务逻辑时，它才可用。EJB 的缺点总体上非常大，以至于这不是一个有吸引力的提议，尤其是在面对声明式事务管理的引人注目的替代方案时。


[[transaction-local]]
== 本地事务

本地事务是特定于资源的，例如与 JDBC 连接关联的事务。本地事务可能更容易使用，但有一个显着的缺点：它们无法跨多个事务资源工作。例如，使用 JDBC 连接管理事务的代码无法在全局 JTA 事务中运行。由于应用服务器不参与事务管理，因此它无法帮助确保跨多个资源的正确性。（值得注意的是，大多数应用程序使用单个事务资源。）另一个缺点是本地事务对编程模型具有侵入性。


[[transaction-programming-model]]
== TODAY Framework 的一致编程模型

Infra 解决了全局和本地事务的缺点。它允许应用程序开发人员在任何环境中使用一致的编程模型。您只需编写一次代码，它就可以在不同的环境中受益于不同的事务管理策略。TODAY Framework 提供声明式和编程式事务管理。大多数用户更喜欢声明式事务管理，这也是我们在大多数情况下推荐的。

通过编程式事务管理，开发人员使用 TODAY Framework 事务抽象，该抽象可以在任何底层事务基础设施上运行。使用首选的声明式模型，开发人员通常编写很少或根本不编写与事务管理相关的代码，因此不依赖于 TODAY Framework 事务 API 或任何其他事务 API。

.你需要应用服务器来进行事务管理吗？
****
TODAY Framework 的事务管理支持改变了企业 Java 应用程序何时需要应用服务器的传统规则。

特别是，您不需要仅仅为了通过 EJB 进行声明式事务而使用应用服务器。事实上，即使您的应用服务器具有强大的 JTA 功能，您也可能决定 TODAY Framework 的声明式事务比 EJB CMT 提供更强大的功能和更高效的编程模型。

通常，仅当您的应用程序需要处理跨多个资源的事务时，才需要应用服务器的 JTA 功能，但这并非许多应用程序的要求。许多高端应用程序使用单个、高度可扩展的数据库（例如 Oracle RAC）。独立的事务管理器（例如 https://www.atomikos.com/[Atomikos Transactions]）是其他选择。当然，您可能需要其他应用服务器功能，例如 Java 消息服务 (JMS) 和 Jakarta EE 连接器架构 (JCA)。

TODAY Framework 让您可以选择何时将应用程序扩展到完全加载的应用服务器。除了使用 EJB CMT 或 JTA 之外，唯一的替代方案是编写带有本地事务的代码（例如在 JDBC 连接上），并且如果需要该代码在全局、容器管理的事务中运行，则面临繁重的返工，这样的日子已经一去不复返了。使用 TODAY Framework，只有配置文件中的一些 bean 定义需要更改（而不是您的代码）。
****
