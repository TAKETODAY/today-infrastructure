[[tx-resource-synchronization]]
= 将资源与事务同步

现在应该清楚如何创建不同的事务管理器，以及如何将它们链接到需要与事务同步的相关资源（例如 `DataSourceTransactionManager` 到 JDBC `DataSource`，`HibernateTransactionManager` 到 Hibernate `SessionFactory` 等）。本节描述应用程序代码（直接或间接，通过使用诸如 JDBC、Hibernate 或 JPA 之类的持久性 API）如何确保正确创建、重用和清理这些资源。本节还讨论了如何通过相关的 `TransactionManager`（可选）触发事务同步。


[[tx-resource-synchronization-high]]
== 高级同步方法

首选方法是使用 Infra 最高级别的基于模板的持久性集成 API，或使用具有事务感知工厂 bean 或代理的原生 ORM API 来管理原生资源工厂。这些事务感知解决方案在内部处理资源创建和重用、清理、资源的可选事务同步以及异常映射。因此，用户数据访问代码不必处理这些任务，而可以纯粹专注于非样板持久性逻辑。通常，您使用原生 ORM API 或通过使用 `JdbcTemplate` 采用模板方法进行 JDBC 访问。这些解决方案在本参考文档的后续部分中详细介绍。


[[tx-resource-synchronization-low]]
== 低级同步方法

诸如 `DataSourceUtils`（用于 JDBC）、`EntityManagerFactoryUtils`（用于 JPA）、`SessionFactoryUtils`（用于 Hibernate）等类存在于较低级别。当您希望应用程序代码直接处理原生持久性 API 的资源类型时，您使用这些类来确保获得正确的 TODAY Framework 管理的实例，事务被（可选）同步，并且过程中发生的异常被正确映射到一致的 API。

例如，在 JDBC 的情况下，您可以不使用在 `DataSource` 上调用 `getConnection()` 方法的传统 JDBC 方法，而是使用 Infra `infra.jdbc.datasource.DataSourceUtils` 类，如下所示：

[source,java,indent=0,subs="verbatim,quotes"]
----
	Connection conn = DataSourceUtils.getConnection(dataSource);
----

如果现有事务已经有同步（链接）到它的连接，则返回该实例。否则，方法调用会触发创建新连接，该连接（可选）与任何现有事务同步，并可用于在同一事务中后续重用。如前所述，任何 `SQLException` 都包装在 TODAY Framework `CannotGetJdbcConnectionException` 中，这是 TODAY Framework 未经检查的 `DataAccessException` 类型层次结构之一。这种方法为您提供了比从 `SQLException` 轻松获得的信息更多的信息，并确保了跨数据库甚至跨不同持久性技术的可移植性。

这种方法也可以在没有 Infra 事务管理的情况下工作（事务同步是可选的），因此无论您是否使用 Infra 进行事务管理，都可以使用它。

当然，一旦您使用了 Infra JDBC 支持、JPA 支持或 Hibernate 支持，您通常更喜欢不使用 `DataSourceUtils` 或其他辅助类，因为您通过 Infra 抽象比直接使用相关 API 工作得更开心。例如，如果您使用 Infra `JdbcTemplate` 或 `jdbc.object` 包来简化 JDBC 的使用，则正确的连接检索会在幕后发生，您无需编写任何特殊代码。


[[tx-resource-synchronization-tadsp]]
== `TransactionAwareDataSourceProxy`

在最低级别存在 `TransactionAwareDataSourceProxy` 类。这是目标 `DataSource` 的代理，它包装目标 `DataSource` 以增加对 Infra 管理事务的感知。在这方面，它类似于 Jakarta EE 服务器提供的事务性 JNDI `DataSource`。

除非必须调用现有代码并传递标准 JDBC `DataSource` 接口实现，否则您几乎永远不需要或不希望使用此类。在这种情况下，此代码可能是可用的，但正在参与 Infra 管理的事务。您可以使用前面提到的更高级别的抽象来编写新代码。
