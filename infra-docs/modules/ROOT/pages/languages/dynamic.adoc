[[dynamic-language]]
= 动态语言支持

Infra 为使用由动态语言（如 Groovy）定义的类和对象提供了全面的支持。
这种支持使您能够用受支持的动态语言编写任意数量的类，并让 Infra 容器透明地实例化、配置和依赖注入生成的对象。

Infra 脚本支持主要针对 Groovy 和 BeanShell。除了这些特定支持的语言外，JSR-223 脚本机制也被支持，
用于与任何支持 JSR-223 的语言提供者集成，例如 JRuby。

您可以在 xref:languages/dynamic.adoc#dynamic-language-scenarios[场景] 中找到这种动态语言支持可以立即发挥作用的完整工作示例。




[[dynamic-language-a-first-example]]
== 第一个示例

本章的大部分内容都在详细描述动态语言支持。在深入研究动态语言支持的所有细节之前，我们先看一个用动态语言定义的 bean 的快速示例。
这个第一个 bean 的动态语言是 Groovy。（此示例的基础取自 Infra 测试套件。如果您想查看其他任何受支持语言的等效示例，请查看源代码）。

下一个示例显示了 `Messenger` 接口，Groovy bean 将实现该接口。请注意，此接口是用纯 Java 定义的。
被注入了对 `Messenger` 引用的依赖对象并不知道底层实现是一个 Groovy 脚本。以下清单显示了 `Messenger` 接口：

[source,java,indent=0,subs="verbatim,quotes",chomp="-packages"]
----
package infra.scripting;

public interface Messenger {

  String getMessage();
}
----

以下示例定义了一个依赖于 `Messenger` 接口的类：

[source,java,indent=0,subs="verbatim,quotes",chomp="-packages"]
----
package infra.scripting;

public class DefaultBookingService implements BookingService {

  private Messenger messenger;

  public void setMessenger(Messenger messenger) {
    this.messenger = messenger;
  }

  public void processBooking() {
    // 使用注入的 Messenger 对象...
  }
}
----

以下示例用 Groovy 实现了 `Messenger` 接口：

[source,groovy,indent=0,subs="verbatim,quotes",chomp="-packages",fold="none"]
----
package infra.scripting.groovy

// 导入要实现的 Messenger 接口（用 Java 编写）
import infra.scripting.Messenger

// 在文件 'Messenger.groovy' 中用 Groovy 定义实现
class GroovyMessenger implements Messenger {

  String message
}
----

[NOTE]
====
要使用自定义动态语言标签来定义由动态语言支持的 bean，您需要在 Infra XML 配置文件顶部包含 XML Schema 序言。
您还需要使用 Infra `ApplicationContext` 实现作为您的 IoC 容器。虽然支持使用纯 `BeanFactory` 实现来使用由动态语言支持的 bean，
但您必须为此管理 Infra 内部的管道。

有关基于 Schema 的配置的更多信息，请参阅 xref:languages/dynamic.adoc#xsd-schemas-lang[基于 XML Schema 的配置]。
====

最后，以下示例显示了将 Groovy 定义的 `Messenger` 实现注入到 `DefaultBookingService` 类实例中的 bean 定义：

[source,xml,indent=0,subs="verbatim,quotes"]
----
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xmlns:lang="http://www.springframework.org/schema/lang"
  xsi:schemaLocation="
    http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd
    http://www.springframework.org/schema/lang https://www.springframework.org/schema/lang/spring-lang.xsd">

  <!-- 这是由 Groovy 支持的 Messenger 实现的 bean 定义 -->
  <lang:groovy id="messenger" script-source="classpath:Messenger.groovy">
    <lang:property name="message" value="I Can Do The Frug" />
  </lang:groovy>

  <!-- 一个将被注入 Groovy 支持的 Messenger 的普通 bean -->
  <bean id="bookingService" class="x.y.DefaultBookingService">
    <property name="messenger" ref="messenger" />
  </bean>

</beans>
----

`bookingService` bean（一个 `DefaultBookingService`）现在可以像往常一样使用其私有的 `messenger` 成员变量，
因为注入其中的 `Messenger` 实例就是一个 `Messenger` 实例。这里没有什么特别的事情发生——只是普通的 Java 和普通的 Groovy。

希望前面的 XML 代码片段是不言自明的，但如果不是，也不必过分担心。请继续阅读以深入了解上述配置的来龙去脉。




[[dynamic-language-beans]]
== 定义由动态语言支持的 Bean

本节详细描述如何在任何受支持的动态语言中定义 Infra 管理的 bean。

请注意，本章并不试图解释受支持动态语言的语法和习语。例如，如果您想使用 Groovy 编写应用程序中的某些类，我们假设您已经了解 Groovy。
如果您需要有关动态语言本身的更多详细信息，请参阅本章末尾的 xref:languages/dynamic.adoc#dynamic-language-resources[更多资源]。



[[dynamic-language-beans-concepts]]
=== 通用概念

使用由动态语言支持的 bean 的步骤如下：

. 编写动态语言源代码的测试（自然地）。
. 然后编写动态语言源代码本身。
. 在 XML 配置中使用适当的 `<lang:language/>` 元素定义由动态语言支持的 bean（虽然您可以使用 Infra API 以编程方式定义此类 bean，
  但您必须查阅源代码以获取有关如何执行此操作的说明，因为本章不涵盖此类高级配置）。
  请注意，这是一个迭代步骤。每个动态语言源文件至少需要一个 bean 定义（尽管多个 bean 定义可以引用同一个源文件）。

前两个步骤（测试和编写动态语言源文件）超出了本章的范围。请参阅您选择的动态语言的语言规范和参考手册，并着手开发您的动态语言源文件。
不过，您首先要阅读本章的其余部分，因为 Infra 动态语言支持确实对您的动态语言源文件的内容做了一些（小的）假设。


[[dynamic-language-beans-concepts-xml-language-element]]
==== <lang:language/> 元素

xref:languages/dynamic.adoc#dynamic-language-beans-concepts[上一节] 列表中最后一步涉及定义由动态语言支持的 bean 定义，
为您想要配置的每个 bean 定义一个（这与普通的 JavaBean 配置没有什么不同）。但是，您可以使用 `<lang:language/>` 元素来定义由动态语言支持的 bean，
而不是指定要由容器实例化和配置的类的完全限定类名。

每种受支持的语言都有一个对应的 `<lang:language/>` 元素：

* `<lang:groovy/>` (Groovy)
* `<lang:bsh/>` (BeanShell)
* `<lang:std/>` (JSR-223, 例如使用 JRuby)

可用于配置的确切属性和子元素取决于 bean 定义所用的确切语言（本章后面的特定语言部分将对此进行详细说明）。


[[dynamic-language-refreshable-beans]]
==== 可刷新 Bean

Infra 中动态语言支持的最引人注目的增值之一（也许是唯一的）是“`可刷新 bean`”功能。

可刷新 bean 是一个由动态语言支持的 bean。通过少量的配置，由动态语言支持的 bean 可以监视其底层源文件资源的更改，
并在动态语言源文件更改时（例如，当您在文件系统上编辑并保存对文件的更改时）重新加载自身。

这使您可以将任意数量的动态语言源文件部署为应用程序的一部分，配置 Infra 容器以创建由动态语言源文件支持的 bean（使用本章描述的机制），
并且（稍后，随着需求的变化或某些其他外部因素的介入）编辑动态语言源文件，并使其所做的任何更改反映在由更改后的动态语言源文件支持的 bean 中。
无需关闭正在运行的应用程序（或在 Web 应用程序的情况下重新部署）。经如此修改的由动态语言支持的 bean 会从更改后的动态语言源文件中获取新的状态和逻辑。

NOTE: 此功能默认是关闭的。

现在我们可以看一个例子，看看开始使用可刷新 bean 是多么容易。要打开可刷新 bean 功能，您必须在 bean 定义的 `<lang:language/>` 元素上指定一个附加属性。
因此，如果我们坚持使用本章前面的 xref:languages/dynamic.adoc#dynamic-language-a-first-example[示例]，以下示例显示了我们需要在 Infra XML 配置中更改什么以实现可刷新 bean：

[source,xml,indent=0,subs="verbatim,quotes"]
----
<beans>

  <!-- 由于存在 'refresh-check-delay' 属性，此 bean 现在是 '可刷新' 的 -->
  <lang:groovy id="messenger"
      refresh-check-delay="5000" <!-- 开启刷新，检查间隔为 5 秒 -->
      script-source="classpath:Messenger.groovy">
    <lang:property name="message" value="I Can Do The Frug" />
  </lang:groovy>

  <bean id="bookingService" class="x.y.DefaultBookingService">
    <property name="messenger" ref="messenger" />
  </bean>

</beans>
----

这真的是您所要做的一切。在 `messenger` bean 定义上定义的 `refresh-check-delay` 属性是 bean 在使用底层动态语言源文件的任何更改进行刷新之前的毫秒数。
您可以通过为 `refresh-check-delay` 属性分配负值来关闭刷新行为。请记住，默认情况下，刷新行为是禁用的。如果您不需要刷新行为，请不要定义该属性。

如果我们随后运行以下应用程序，我们可以练习可刷新功能。（请原谅下一个代码片段中的“`跳圈暂停执行`”的把戏。）
`System.in.read()` 调用仅用于在程序执行暂停时让您（此场景中的开发人员）去编辑底层动态语言源文件，以便在程序恢复执行时触发对由动态语言支持的 bean 的刷新。

以下清单显示了此示例应用程序：

[source,java,indent=0,subs="verbatim,quotes"]
----
import infra.context.ApplicationContext;
import infra.context.support.ClassPathXmlApplicationContext;
import infra.scripting.Messenger;

public final class Boot {

  public static void main(final String[] args) throws Exception {
    ApplicationContext ctx = new ClassPathXmlApplicationContext("beans.xml");
    Messenger messenger = (Messenger) ctx.getBean("messenger");
    System.out.println(messenger.getMessage());
    // 暂停执行，我去对源文件进行更改...
    System.in.read();
    System.out.println(messenger.getMessage());
  }
}
----

假设为了这个例子的目的，所有对 `Messenger` 实现的 `getMessage()` 方法的调用都必须更改，以便消息被引号包围。
以下清单显示了当程序执行暂停时，您（开发人员）应该对 `Messenger.groovy` 源文件进行的更改：

[source,groovy,indent=0,subs="verbatim,quotes",chomp="-packages"]
----
package infra.scripting

class GroovyMessenger implements Messenger {

  private String message = "Bingo"

  public String getMessage() {
    // 更改实现以将消息用引号括起来
    return "'" + this.message + "'"
  }

  public void setMessage(String message) {
    this.message = message
  }
}
----

当程序运行时，输入暂停前的输出将是 `I Can Do The Frug`。在对源文件进行更改并保存且程序恢复执行后，
在由动态语言支持的 `Messenger` 实现上调用 `getMessage()` 方法的结果是 `'I Can Do The Frug'`（注意包含了额外的引号）。

如果更改发生在 `refresh-check-delay` 值的窗口内，脚本的更改不会触发刷新。实际上，直到在由动态语言支持的 bean 上调用方法时，脚本的更改才会被提取。
只有在由动态语言支持的 bean 上调用方法时，它才会检查其底层脚本源是否已更改。任何与刷新脚本相关的异常（例如遇到编译错误或发现脚本文件已被删除）都会导致致命异常传播到调用代码。

前面描述的可刷新 bean 行为不适用于使用 `<lang:inline-script/>` 元素表示法定义的动态语言源文件（请参阅 xref:languages/dynamic.adoc#dynamic-language-beans-inline[内联动态语言源文件]）。
此外，它仅适用于可以实际检测到底层源文件更改的 bean（例如，通过检查文件系统上存在的动态语言源文件的最后修改日期）。


[[dynamic-language-beans-inline]]
==== 内联动态语言源文件

动态语言支持还可以满足直接嵌入在 Infra bean 定义中的动态语言源文件的需求。更具体地说，`<lang:inline-script/>` 元素允许您直接在 Infra 配置文件中定义动态语言源代码。
一个例子可能会阐明内联脚本功能的工作原理：

[source,xml,indent=0,subs="verbatim,quotes"]
----
<lang:groovy id="messenger">
  <lang:inline-script>

    package infra.scripting.groovy

    import infra.scripting.Messenger

    class GroovyMessenger implements Messenger {
      String message
    }

  </lang:inline-script>
  <lang:property name="message" value="I Can Do The Frug" />
</lang:groovy>
----

如果我们把关于在 Infra 配置文件中定义动态语言源代码是否是好的做法的问题放在一边，`<lang:inline-script/>` 元素在某些场景中可能是有用的。
例如，我们可能想要快速向 Web MVC `Controller` 添加一个 Infra `Validator` 实现。使用内联源代码这只是片刻的工作。
（有关此类示例，请参阅 xref:languages/dynamic.adoc#dynamic-language-scenarios-validators[脚本化验证器]。）


[[dynamic-language-beans-ctor-injection]]
==== 理解动态语言支持 Bean 上下文中的构造函数注入

关于 Infra 动态语言支持，有一件非常重要的事情需要注意。即，您（目前）不能为由动态语言支持的 bean 提供构造函数参数（因此，构造函数注入不可用于由动态语言支持的 bean）。
为了使这种对构造函数和属性的特殊处理 100% 清楚，以下代码和配置的混合是行不通的：

.一种行不通的方法
[source,groovy,indent=0,subs="verbatim,quotes",chomp="-packages"]
----
package infra.scripting.groovy

import infra.scripting.Messenger

// 来自文件 'Messenger.groovy'
class GroovyMessenger implements Messenger {

  GroovyMessenger() {}

  // 此构造函数不可用于构造函数注入
  GroovyMessenger(String message) {
    this.message = message;
  }

  String message

  String anotherMessage
}
----

[source,xml,indent=0,subs="verbatim,quotes"]
----
<lang:groovy id="badMessenger"
  script-source="classpath:Messenger.groovy">
  <!-- 下一个构造函数参数将不会注入到 GroovyMessenger 中 -->
  <!-- 事实上，根据 schema 这甚至是不允许的 -->
  <constructor-arg value="This will not work" />

  <!-- 只有属性值会被注入到由动态语言支持的对象中 -->
  <lang:property name="anotherMessage" value="Passed straight through to the dynamic-language-backed object" />

</lang>
----

在实践中，这种限制并不像最初看起来那么重要，因为 setter 注入是绝大多数开发人员所青睐的注入风格（我们将关于这是否是一件好事的讨论留待改日）。



[[dynamic-language-beans-groovy]]
=== Groovy Beans

本节描述如何在 Infra 中使用用 Groovy 定义的 bean。

Groovy 主页包含以下描述：

“`Groovy 是一种用于 Java 2 平台的敏捷动态语言，它具有 Python、Ruby 和 Smalltalk 等语言中人们非常喜欢的许多特性，使其可供使用类似 Java 语法的 Java 开发人员使用。`”

如果您从头阅读本章，您已经 xref:languages/dynamic.adoc#dynamic-language-a-first-example[看过一个示例] 的 Groovy 动态语言支持的 bean。
现在考虑另一个示例（再次使用来自 Infra 测试套件的示例）：

[source,java,indent=0,subs="verbatim,quotes",chomp="-packages"]
----
package infra.scripting;

public interface Calculator {

  int add(int x, int y);
}
----

以下示例用 Groovy 实现了 `Calculator` 接口：

[source,groovy,indent=0,subs="verbatim,quotes",chomp="-packages"]
----
package infra.scripting.groovy

// 来自文件 'calculator.groovy'
class GroovyCalculator implements Calculator {

  int add(int x, int y) {
    x + y
  }
}
----

以下 bean 定义使用在 Groovy 中定义的计算器：

[source,xml,indent=0,subs="verbatim,quotes"]
----
<!-- 来自文件 'beans.xml' -->
<beans>
  <lang:groovy id="calculator" script-source="classpath:calculator.groovy"/>
</beans>
----

最后，以下小程序练习了前面的配置：

[source,java,indent=0,subs="verbatim,quotes",chomp="-packages"]
----
package infra.scripting;

import infra.context.ApplicationContext;
import infra.context.support.ClassPathXmlApplicationContext;

public class Main {

  public static void main(String[] args) {
    ApplicationContext ctx = new ClassPathXmlApplicationContext("beans.xml");
    Calculator calc = ctx.getBean("calculator", Calculator.class);
    System.out.println(calc.add(2, 8));
  }
}
----

运行上述程序的结果输出（不出所料）是 `10`。（有关更有趣的示例，请参阅动态语言展示项目以获取更复杂的示例，或者参阅本章后面的 xref:languages/dynamic.adoc#dynamic-language-scenarios[场景] 示例）。

每个 Groovy 源文件不得定义超过一个类。虽然这在 Groovy 中是完全合法的，但（可以说）这是一种不好的做法。为了保持一致的方法，您应该（根据 Infra 团队的意见）遵守每个源文件一个（公共）类的标准 Java 约定。


[[dynamic-language-beans-groovy-customizer]]
==== 使用回调自定义 Groovy 对象

`GroovyObjectCustomizer` 接口是一个回调，允许您将额外的创建逻辑挂钩到创建 Groovy 支持的 bean 的过程中。
例如，此接口的实现可以调用任何所需的初始化方法，设置一些默认属性值，或指定自定义 `MetaClass`。
以下清单显示了 `GroovyObjectCustomizer` 接口定义：

[source,java,indent=0,subs="verbatim,quotes"]
----
public interface GroovyObjectCustomizer {

  void customize(GroovyObject goo);
}
----

Infra Framework 实例化您的 Groovy 支持的 bean 的实例，然后将创建的 `GroovyObject` 传递给指定的 `GroovyObjectCustomizer`（如果已定义）。
您可以对提供的 `GroovyObject` 引用做任何您想做的事情。我们预计大多数人希望使用此回调设置自定义 `MetaClass`，以下示例显示了如何这样做：

[source,java,indent=0,subs="verbatim,quotes"]
----
public final class SimpleMethodTracingCustomizer implements GroovyObjectCustomizer {

  public void customize(GroovyObject goo) {
    DelegatingMetaClass metaClass = new DelegatingMetaClass(goo.getMetaClass()) {

      public Object invokeMethod(Object object, String methodName, Object[] arguments) {
        System.out.println("Invoking '" + methodName + "'.");
        return super.invokeMethod(object, methodName, arguments);
      }
    };
    metaClass.initialize();
    goo.setMetaClass(metaClass);
  }

}
----

关于 Groovy 中元编程的全面讨论超出了 Infra 参考手册的范围。请参阅 Groovy 参考手册的相关部分或在线搜索。有很多文章涉及这个主题。
实际上，如果您使用 Infra 命名空间支持，利用 `GroovyObjectCustomizer` 是很容易的，如下例所示：

[source,xml,indent=0,subs="verbatim,quotes"]
----
<!-- 像定义任何其他 bean 一样定义 GroovyObjectCustomizer -->
<bean id="tracingCustomizer" class="example.SimpleMethodTracingCustomizer"/>

  <!-- ... 并通过 'customizer-ref' 属性将其插入所需的 Groovy bean -->
  <lang:groovy id="calculator"
    script-source="classpath:infra/scripting/groovy/Calculator.groovy"
    customizer-ref="tracingCustomizer"/>
----

如果您不使用 Infra 命名空间支持，您仍然可以使用 `GroovyObjectCustomizer` 功能，如下例所示：

[source,xml,indent=0,subs="verbatim,quotes"]
----
<bean id="calculator" class="infra.scripting.groovy.GroovyScriptFactory">
  <constructor-arg value="classpath:infra/scripting/groovy/Calculator.groovy"/>
  <!-- 定义 GroovyObjectCustomizer（作为内部 bean） -->
  <constructor-arg>
    <bean id="tracingCustomizer" class="example.SimpleMethodTracingCustomizer"/>
  </constructor-arg>
</bean>

<bean class="infra.scripting.support.ScriptFactoryPostProcessor"/>
----

NOTE: 您还可以在与 Infra `GroovyObjectCustomizer` 相同的位置指定 Groovy `CompilationCustomizer`（例如 `ImportCustomizer`）
甚至完整的 Groovy `CompilerConfiguration` 对象。此外，您可以在 `ConfigurableApplicationContext.setClassLoader` 级别为您的 bean 设置具有自定义配置的通用 `GroovyClassLoader`；
这也会导致共享 `GroovyClassLoader` 使用，因此在有大量脚本 bean 的情况下是推荐的（避免每个 bean 一个隔离的 `GroovyClassLoader` 实例）。



[[dynamic-language-beans-bsh]]
=== BeanShell Beans

本节描述如何在 Infra 中使用 BeanShell bean。

https://beanshell.github.io/intro.html[BeanShell 主页] 包含以下描述：

----
BeanShell 是一个小型、免费、可嵌入的 Java 源代码解释器，具有动态语言特性，用 Java 编写。
BeanShell 动态运行标准 Java 语法，并使用常见的脚本便利扩展它，如松散类型、命令和像 Perl 和 JavaScript 中的方法闭包。
----

与 Groovy 相比，BeanShell 支持的 bean 定义需要一些（小的）额外配置。Infra 中 BeanShell 动态语言支持的实现很有趣，
因为 Infra 创建了一个 JDK 动态代理，该代理实现了 `<lang:bsh>` 元素的 `script-interfaces` 属性值中指定的所有接口
（这就是为什么您必须在属性值中至少提供一个接口，并且因此在使用 BeanShell 支持的 bean 时面向接口编程）。
这意味着对 BeanShell 支持的对象的每个方法调用都经过 JDK 动态代理调用机制。

现在我们可以展示一个使用实现本章前面定义的 `Messenger` 接口的 BeanShell bean 的完整工作示例。我们再次展示 `Messenger` 接口的定义：

[source,java,indent=0,subs="verbatim,quotes",chomp="-packages"]
----
package infra.scripting;

public interface Messenger {

  String getMessage();
}
----

以下示例显示了 `Messenger` 接口的 BeanShell “`实现`”（我们在这里宽松地使用这个术语）：

[source,java,indent=0,subs="verbatim,quotes"]
----
String message;

String getMessage() {
  return message;
}

void setMessage(String aMessage) {
  message = aMessage;
}
----

以下示例显示了定义上述“`类`”的“`实例`”的 Infra XML（同样，我们在这里非常宽松地使用这些术语）：

[source,xml,indent=0,subs="verbatim,quotes"]
----
<lang:bsh id="messageService" script-source="classpath:BshMessenger.bsh"
  script-interfaces="infra.scripting.Messenger">

  <lang:property name="message" value="Hello World!" />
</lang:bsh>
----

有关可能想要使用基于 BeanShell 的 bean 的一些场景，请参阅 xref:languages/dynamic.adoc#dynamic-language-scenarios[场景]。




[[dynamic-language-scenarios]]
== 场景

在脚本语言中定义 Infra 管理的 bean 可能有益的可能场景多种多样。本节描述了 Infra 中动态语言支持的两个可能的用例。



[[dynamic-language-scenarios-controllers]]
=== 脚本化 Web MVC 控制器

一类可以从使用由动态语言支持的 bean 中受益的类是 Web MVC 控制器。在纯 Web MVC 应用程序中，通过 Web 应用程序的导航流在很大程度上由封装在 Web MVC 控制器中的代码决定。
随着 Web 应用程序的导航流和其他表示层逻辑需要更新以响应支持问题或不断变化的业务需求，通过编辑一个或多个动态语言源文件并看到这些更改立即反映在正在运行的应用程序的状态中，可能会更容易实现任何此类所需的更改。

请记住，在 Infra 等项目支持的轻量级架构模型中，您通常旨在拥有一个非常薄的表示层，应用程序的所有实质性业务逻辑都包含在领域和服务层类中。
将 Web MVC 控制器开发为由动态语言支持的 bean 允许您通过编辑和保存文本文件来更改表示层逻辑。
对这些动态语言源文件的任何更改（取决于配置）都会自动反映在由动态语言源文件支持的 bean 中。

NOTE: 要实现对由动态语言支持的 bean 的任何更改的自动“`提取`”，您必须启用“`可刷新 bean`”功能。
有关此功能的完整处理，请参阅 xref:languages/dynamic.adoc#dynamic-language-refreshable-beans[可刷新 Bean]。

以下示例显示了使用 Groovy 动态语言实现的 `infra.web.hanler.mvc.Controller`：

[source,groovy,indent=0,subs="verbatim,quotes",chomp="-packages"]
----
package infra.showcase.fortune.web

import infra.showcase.fortune.service.FortuneService
import infra.showcase.fortune.domain.Fortune
import infra.web.mock.ModelAndView
import infra.web.mock.mvc.Controller

import jakarta.servlet.http.HttpServletRequest
import jakarta.servlet.http.HttpServletResponse

// 来自文件 '/WEB-INF/groovy/FortuneController.groovy'
class FortuneController implements Controller {

  @Property FortuneService fortuneService

  ModelAndView handleRequest(HttpServletRequest request,
      HttpServletResponse httpServletResponse) {
    return new ModelAndView("tell", "fortune", this.fortuneService.tellFortune())
  }
}
----

[source,xml,indent=0,subs="verbatim,quotes"]
----
<lang:groovy id="fortune"
    refresh-check-delay="3000"
    script-source="/WEB-INF/groovy/FortuneController.groovy">
  <lang:property name="fortuneService" ref="fortuneService"/>
</lang:groovy>
----



[[dynamic-language-scenarios-validators]]
=== 脚本化验证器

使用 Infra 进行应用程序开发的另一个可能受益于由动态语言支持的 bean 提供的灵活性的领域是验证。
使用松散类型的动态语言（可能还支持内联正则表达式）表达复杂的验证逻辑可能比使用常规 Java 更容易。

同样，将验证器开发为由动态语言支持的 bean 允许您通过编辑和保存简单的文本文件来更改验证逻辑。
任何此类更改（取决于配置）都会自动反映在正在运行的应用程序的执行中，而无需重新启动应用程序。

NOTE: 要实现对由动态语言支持的 bean 的任何更改的自动“`提取`”，您必须启用“可刷新 bean”功能。
有关此功能的完整和详细处理，请参阅 xref:languages/dynamic.adoc#dynamic-language-refreshable-beans[可刷新 Bean]。

以下示例显示了使用 Groovy 动态语言实现的 Infra `infra.validation.Validator`（有关 `Validator` 接口的讨论，
请参阅 xref:core/validation/validator.adoc[使用 Infra 的 Validator 接口进行验证]）：

[source,groovy,indent=0,subs="verbatim,quotes"]
----
import infra.validation.Validator
import infra.validation.Errors
import infra.beans.TestBean

class TestBeanValidator implements Validator {

  boolean supports(Class clazz) {
    return TestBean.class.isAssignableFrom(clazz)
  }

  void validate(Object bean, Errors errors) {
    if(bean.name?.trim()?.size() > 0) {
      return
    }
    errors.reject("whitespace", "Cannot be composed wholly of whitespace.")
  }
}
----




[[dynamic-language-final-notes]]
== 其他细节

最后一部分包含一些与动态语言支持相关的其他细节。



[[dynamic-language-final-notes-aop]]
=== AOP -- 通知脚本化 Bean

您可以使用 Infra AOP 框架来通知脚本化 bean。Infra AOP 框架实际上不知道被通知的 bean 可能是脚本化 bean，
因此您使用（或旨在以使用）的所有 AOP 用例和功能都适用于脚本化 bean。当您通知脚本化 bean 时，您不能使用基于类的代理。
您必须使用 xref:core/aop/proxying.adoc[基于接口的代理]。

您不仅限于通知脚本化 bean。您还可以用受支持的动态语言编写切面本身，并使用这些 bean 来通知其他 Infra bean。
但这确实是动态语言支持的高级用法。



[[dynamic-language-final-notes-scopes]]
=== 作用域

如果这不明显，脚本化 bean 可以像任何其他 bean 一样确定作用域。各种 `<lang:language/>` 元素上的 `scope` 属性允许您控制底层脚本化 bean 的作用域，
就像它对常规 bean 所做的那样。（默认作用域是 xref:core/beans/factory-scopes.adoc#beans-factory-scopes-singleton[单例]，就像“`常规`”bean 一样。）

以下示例使用 `scope` 属性将 Groovy bean 定义为 xref:core/beans/factory-scopes.adoc#beans-factory-scopes-prototype[原型] 作用域：

[source,xml,indent=0,subs="verbatim,quotes"]
----
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xmlns:lang="http://www.springframework.org/schema/lang"
  xsi:schemaLocation="
    http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd
    http://www.springframework.org/schema/lang https://www.springframework.org/schema/lang/spring-lang.xsd">

  <lang:groovy id="messenger" script-source="classpath:Messenger.groovy" scope="prototype">
    <lang:property name="message" value="I Can Do The RoboCop" />
  </lang:groovy>

  <bean id="bookingService" class="x.y.DefaultBookingService">
    <property name="messenger" ref="messenger" />
  </bean>

</beans>
----

有关 TODAY Framework 中作用域支持的完整讨论，请参阅 xref:web/webmvc-view/mvc-xslt.adoc#mvc-view-xslt-beandefs[IoC 容器] 中的 xref:core/beans/factory-scopes.adoc[Bean 作用域]。



[[xsd-schemas-lang]]
=== `lang` XML schema

Infra XML 配置中的 `lang` 元素用于将以动态语言（如 Groovy 或 BeanShell）编写的对象作为 bean 暴露在 Infra 容器中。

这些元素（以及动态语言支持）在 xref:languages/dynamic.adoc[动态语言支持] 中有全面介绍。请参阅该部分以获取有关此支持和 `lang` 元素的完整详细信息。

要使用 `lang` schema 中的元素，您需要在 Infra XML 配置文件顶部包含以下序言。以下代码段中的文本引用了正确的 schema，以便 `lang` 命名空间中的标签可供您使用：

[source,xml,indent=0,subs="verbatim,quotes"]
----
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xmlns:lang="http://www.springframework.org/schema/lang"
  xsi:schemaLocation="
    http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd
    http://www.springframework.org/schema/lang https://www.springframework.org/schema/lang/spring-lang.xsd">

  <!-- bean definitions here -->

</beans>
----




[[dynamic-language-resources]]
== 更多资源

以下链接指向有关本章中引用的各种动态语言的更多资源：

* https://www.groovy-lang.org/[Groovy] 主页
* https://beanshell.github.io/intro.html[BeanShell] 主页
* https://www.jruby.org[JRuby] 主页
