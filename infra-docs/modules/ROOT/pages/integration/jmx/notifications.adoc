[[jmx-notifications]]
= 通知

Infra JMX 产品包括对 JMX 通知的全面支持。

[[jmx-notifications-listeners]]
== 注册通知监听器

Infra JMX 支持使得向任意数量的 MBean 注册任意数量的 `NotificationListeners` 变得容易（这包括由 Infra `MBeanExporter` 导出的 MBean 和通过其他机制注册的 MBean）。
例如，考虑这样一种情况：每当目标 MBean 的属性发生更改时，我们都希望收到通知（通过 `Notification`）。
以下示例将通知写入控制台：

[source,java,indent=0,subs="verbatim,quotes",chomp="-packages"]
----
package com.example;

import javax.management.AttributeChangeNotification;
import javax.management.Notification;
import javax.management.NotificationFilter;
import javax.management.NotificationListener;

public class ConsoleLoggingNotificationListener
    implements NotificationListener, NotificationFilter {

  public void handleNotification(Notification notification, Object handback) {
    System.out.println(notification);
    System.out.println(handback);
  }

  public boolean isNotificationEnabled(Notification notification) {
    return AttributeChangeNotification.class.isAssignableFrom(notification.getClass());
  }

}
----

以下示例将 `ConsoleLoggingNotificationListener`（在前面的示例中定义）添加到 `notificationListenerMappings`：

[source,xml,indent=0,subs="verbatim,quotes"]
----
<beans>

  <bean id="exporter" class="infra.jmx.export.MBeanExporter">
    <property name="beans">
      <map>
        <entry key="bean:name=testBean1" value-ref="testBean"/>
      </map>
    </property>
    <property name="notificationListenerMappings">
      <map>
        <entry key="bean:name=testBean1">
          <bean class="com.example.ConsoleLoggingNotificationListener"/>
        </entry>
      </map>
    </property>
  </bean>

  <bean id="testBean" class="infra.jmx.JmxTestBean">
    <property name="name" value="TEST"/>
    <property name="age" value="100"/>
  </bean>

</beans>
----

有了上述配置，每次从目标 MBean (`bean:name=testBean1`) 广播 JMX `Notification` 时，通过 `notificationListenerMappings` 属性注册为监听器的 `ConsoleLoggingNotificationListener` bean 都会收到通知。
然后，`ConsoleLoggingNotificationListener` bean 可以采取它认为适当的任何操作来响应 `Notification`。

你也可以使用直接的 bean 名称作为导出的 bean 和监听器之间的链接，如下例所示：

[source,xml,indent=0,subs="verbatim,quotes"]
----
<beans>

  <bean id="exporter" class="infra.jmx.export.MBeanExporter">
    <property name="beans">
      <map>
        <entry key="bean:name=testBean1" value-ref="testBean"/>
      </map>
    </property>
    <property name="notificationListenerMappings">
      <map>
        <entry key="__testBean__">
          <bean class="com.example.ConsoleLoggingNotificationListener"/>
        </entry>
      </map>
    </property>
  </bean>

  <bean id="__testBean__" class="infra.jmx.JmxTestBean">
    <property name="name" value="TEST"/>
    <property name="age" value="100"/>
  </bean>

</beans>
----

如果你想为包含的 `MBeanExporter` 导出的所有 bean 注册单个 `NotificationListener` 实例，你可以使用特殊的通配符 (`{asterisk}`) 作为 `notificationListenerMappings` 属性映射中的条目的键，如下例所示：

[source,xml,indent=0,subs="verbatim,quotes"]
----
<property name="notificationListenerMappings">
  <map>
    <entry key="*">
      <bean class="com.example.ConsoleLoggingNotificationListener"/>
    </entry>
  </map>
</property>
----

如果你需要做相反的事情（即，针对一个 MBean 注册多个不同的监听器），你必须改用 `notificationListeners` 列表属性（优先于 `notificationListenerMappings` 属性）。
这次，我们配置 `NotificationListenerBean` 实例，而不是为单个 MBean 配置 `NotificationListener`。
`NotificationListenerBean` 封装了一个 `NotificationListener` 和它要在 `MBeanServer` 中注册的 `ObjectName`（或 `ObjectNames`）。
`NotificationListenerBean` 还封装了许多其他属性，例如 `NotificationFilter` 和可在高级 JMX 通知场景中使用的任意 handback 对象。

使用 `NotificationListenerBean` 实例时的配置与前面介绍的没有太大区别，如下例所示：

[source,xml,indent=0,subs="verbatim,quotes"]
----
<beans>

  <bean id="exporter" class="infra.jmx.export.MBeanExporter">
    <property name="beans">
      <map>
        <entry key="bean:name=testBean1" value-ref="testBean"/>
      </map>
    </property>
    <property name="notificationListeners">
      <list>
        <bean class="infra.jmx.export.NotificationListenerBean">
          <constructor-arg>
            <bean class="com.example.ConsoleLoggingNotificationListener"/>
          </constructor-arg>
          <property name="mappedObjectNames">
            <list>
              <value>bean:name=testBean1</value>
            </list>
          </property>
        </bean>
      </list>
    </property>
  </bean>

  <bean id="testBean" class="infra.jmx.JmxTestBean">
    <property name="name" value="TEST"/>
    <property name="age" value="100"/>
  </bean>

</beans>
----

前面的示例等同于第一个通知示例。
那么，假设我们希望每次引发 `Notification` 时都获得一个 handback 对象，并且我们要通过提供 `NotificationFilter` 来过滤掉无关的 `Notifications`。
以下示例实现了这些目标：

[source,xml,indent=0,subs="verbatim,quotes"]
----
<beans>

  <bean id="exporter" class="infra.jmx.export.MBeanExporter">
    <property name="beans">
      <map>
        <entry key="bean:name=testBean1" value-ref="testBean1"/>
        <entry key="bean:name=testBean2" value-ref="testBean2"/>
      </map>
    </property>
    <property name="notificationListeners">
      <list>
        <bean class="infra.jmx.export.NotificationListenerBean">
          <constructor-arg ref="customerNotificationListener"/>
          <property name="mappedObjectNames">
            <list>
              <!-- 处理来自两个不同 MBean 的通知 -->
              <value>bean:name=testBean1</value>
              <value>bean:name=testBean2</value>
            </list>
          </property>
          <property name="handback">
            <bean class="java.lang.String">
              <constructor-arg value="This could be anything..."/>
            </bean>
          </property>
          <property name="notificationFilter" ref="customerNotificationListener"/>
        </bean>
      </list>
    </property>
  </bean>

  <!-- 省略了其他 bean 定义 -->

</beans>
----

[[jmx-notifications-publishing]]
== 发布通知

Infra 不仅支持接收通知，还支持发布通知。

[[jmx-notifications-publishing-annotations]]
=== @ManagedNotification 注解

你可以使用 `@ManagedNotification` 注解来声明 bean 发出的通知。
这会将通知元数据添加到 MBeanInfo 中，这是 JMX 规范所鼓励的。

[source,java,indent=0,subs="verbatim,quotes"]
----
@ManagedResource
@ManagedNotification(name="MyNotification", notificationTypes={"my.type"})
public class MyBean implements NotificationPublisherAware {

    private NotificationPublisher publisher;

    public void setNotificationPublisher(NotificationPublisher publisher) {
        this.publisher = publisher;
    }

    public void doSomething() {
        // ...
        publisher.sendNotification(new Notification("my.type", this, 0));
    }
}
----

Infra 会自动检测 `NotificationPublisherAware` 接口并注入 `NotificationPublisher`，你可以使用它来发送通知。
这样，你的 bean 就不需要扩展 `NotificationBroadcasterSupport`，从而保持了纯 POJO 风格。
