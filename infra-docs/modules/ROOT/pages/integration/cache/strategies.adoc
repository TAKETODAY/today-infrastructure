[[cache-strategies]]
= 缓存策略

Infra 的缓存抽象提供了灵活的策略来处理缓存键生成和缓存解析。

[[cache-strategies-keygen]]
== 键生成

缓存本质上是键值存储。
每次调用缓存方法时，都需要生成一个唯一的键来标识缓存条目。
默认情况下，Infra 使用 `SimpleKeyGenerator`，它根据方法参数生成键。

其算法如下：

* 如果没有参数，返回 `SimpleKey.EMPTY`。
* 如果只有一个参数，返回该实例。
* 如果有多个参数，返回包含所有参数的 `SimpleKey`。

这种方法适用于大多数情况，只要参数具有自然的键定义并实现了有效的 `hashCode()` 和 `equals()` 方法。
如果不是这种情况，你需要更改策略。

要提供自定义键生成器，你可以实现 `org.springframework.cache.interceptor.KeyGenerator` 接口。

[source,java,indent=0,subs="verbatim,quotes"]
----
public class CustomKeyGenerator implements KeyGenerator {

    public Object generate(Object target, Method method, Object... params) {
        return target.getClass().getSimpleName() + "_" + method.getName() + "_" + StringUtils.arrayToDelimitedString(params, "_");
    }
}
----

然后，你可以在注解中引用它：

[source,java,indent=0,subs="verbatim,quotes"]
----
@Cacheable(keyGenerator = "customKeyGenerator")
public Book findBook(ISBN isbn) { ... }
----

[[cache-strategies-sync]]
== 同步缓存

在多线程环境中，可能会出现多个线程同时尝试加载同一数据的情况（缓存击穿）。
为了避免这种情况，你可以使用 `@Cacheable` 注解的 `sync` 属性。

[source,java,indent=0,subs="verbatim,quotes"]
----
@Cacheable(cacheNames="foos", sync=true)
public Foo executeExpensiveOperation(String id) { ... }
----

当 `sync` 设置为 `true` 时，只有一个线程会执行该方法，其他线程会等待结果。
这通常通过底层缓存提供程序的本机同步功能来实现（如果支持），或者通过 Infra 框架层面的同步来实现。

[[cache-strategies-conditional]]
== 条件缓存

有时，这种方法可能不适合一直缓存（例如，它可能取决于给定的参数）。
缓存注解支持通过 `condition` 参数实现这种功能，该参数采用一个 `SpEL` 表达式，该表达式被评估为 `true` 或 `false`。
如果为 `true`，则缓存该方法；否则，它的行为就像没有缓存一样。

[source,java,indent=0,subs="verbatim,quotes"]
----
@Cacheable(cacheNames="book", condition="#name.length() < 32")
public Book findBook(String name) { ... }
----

此外，还有一个 `unless` 参数，它用于否决将结果放入缓存。
它在方法调用后进行评估，因此它可以访问 `result`。

[source,java,indent=0,subs="verbatim,quotes"]
----
@Cacheable(cacheNames="book", unless="#result.hardback")
public Book findBook(String name) { ... }
----
