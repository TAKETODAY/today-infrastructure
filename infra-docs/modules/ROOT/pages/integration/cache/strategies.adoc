[[cache-strategies]]
= 理解缓存抽象

.缓存与缓冲区
****

术语“`缓冲区`”和“`缓存`”往往互换使用。但这请注意，它们代表不同的事物。传统上，缓冲区用作快速实体和慢速实体之间数据的中间临时存储。由于一方必须等待另一方（这会影响性能），缓冲区通过允许整个数据块一次移动而不是小块移动来缓解这种情况。数据仅从缓冲区写入和读取一次。此外，缓冲区对于至少一方是可见的。

另一方面，根据定义，缓存是隐藏的，任何一方都不知道发生了缓存。它也提高了性能，但是通过让相同的数据以快速的方式被多次读取来实现的。

您可以https://en.wikipedia.org/wiki/Cache_(computing)#The_difference_between_buffer_and_cache[在此处]找到有关缓冲区和缓存之间差异的进一步解释。
****

在其核心，缓存抽象将缓存应用于 Java 方法，从而根据缓存中可用的信息减少执行次数。也就是说，每次调用目标方法时，抽象都会应用一种缓存行为，检查是否已使用给定参数调用了该方法。如果已调用，则返回缓存的结果，而无需调用实际方法。如果该方法尚未被调用，则调用该方法，并将结果缓存并返回给用户，以便下次调用该方法时，返回缓存的结果。这样，昂贵的方法（无论是 CPU 密集型还是 IO 密集型）对于给定的一组参数只能调用一次，并且可以重用结果，而无需再次实际调用该方法。缓存逻辑透明地应用，不会对调用者造成任何干扰。

IMPORTANT: 此方法仅适用于无论调用多少次，对于给定输入（或参数）都保证返回相同输出（结果）的方法。

缓存抽象提供了其他与缓存相关的操作，例如更新缓存内容或删除一个或所有条目的能力。如果缓存处理在应用程序过程中可能发生变化的数据，这些功能非常有用。

与 TODAY Framework 中的其他服务一样，缓存服务是一个抽象（不是缓存实现），需要使用实际存储来存储缓存数据——也就是说，抽象使您免于编写缓存逻辑，但不提供实际的数据存储。这种抽象由 `infra.cache.Cache` 和 `infra.cache.CacheManager` 接口具体化。

Infra 提供了该抽象的 xref:integration/cache/store-configuration.adoc[一些实现]：基于 JDK `java.util.concurrent.ConcurrentMap` 的缓存、Gemfire 缓存、https://github.com/ben-manes/caffeine/wiki[Caffeine] 以及符合 JSR-107 标准的缓存（例如 Ehcache 3.x）。有关插入其他缓存存储和提供程序的更多信息，请参阅 xref:integration/cache/plug.adoc[插入不同的后端缓存]。

IMPORTANT: 缓存抽象对多线程和多进程环境没有特殊处理，因为此类功能由缓存实现处理。

如果您有多进程环境（即部署在多个节点上的应用程序），则需要相应地配置缓存提供程序。根据您的用例，在多个节点上复制相同的数据可能就足够了。但是，如果在应用程序过程中更改数据，则可能需要启用其他传播机制。

缓存特定项直接等同于在使用编程缓存交互时发现的典型 get-if-not-found-then-proceed-and-put-eventually 代码块。
不应用锁，多个线程可能会尝试同时加载同一项。驱逐也是如此。如果多个线程尝试并发更新或驱逐数据，您可能会使用陈旧数据。某些缓存提供程序在该领域提供了高级功能。有关更多详细信息，请参阅缓存提供程序的文档。

要使用缓存抽象，您需要处理两个方面：

* 缓存声明：确定需要缓存的方法及其策略。
* 缓存配置：存储数据并从中读取数据的后备缓存。
