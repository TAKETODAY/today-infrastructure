[[cache-declarative-xml]]
= 基于 XML 的声明式缓存

如果注解不是一种选择（可能是因为无法访问源代码或没有外部代码），则可以使用 XML 进行声明式缓存。
因此，与其注解缓存方法，不如在外部指定目标方法和缓存指令（类似于声明式事务管理建议）。
上一节中的示例可以转换为以下示例：

[source,xml,indent=0,subs="verbatim,quotes"]
----
<!-- 缓存建议 -->
<cache:advice id="cacheAdvice" cache-manager="cacheManager">
    <cache:caching cache="books">
        <cache:cacheable method="findBook" key="#isbn"/>
        <cache:cache-evict method="loadBooks" all-entries="true"/>
    </cache:caching>
</cache:advice>

<!-- 应用缓存建议 -->
<aop:config>
    <aop:advisor advice-ref="cacheAdvice" pointcut="execution(* com.example.BookRepository.*(..))"/>
</aop:config>
----

在前面的配置中，`bookService` 被设为可缓存的。
应用的缓存语义封装在 `cache:advice` 定义中，这会导致 `findBook` 方法用于将数据放入缓存，而 `loadBooks` 方法用于逐出数据。
这两个定义都针对 `books` 缓存。

`aop:config` 定义应用缓存建议到程序的适当点（通过使用 AspectJ 切入点表达式）。
在前面的示例中，`BookRepository` 中的所有方法都被考虑，并将建议应用于它们。

基于 XML 的配置允许更灵活地定义切入点，这在注解中是不可能的（因为注解只能应用于特定的方法或类）。
此外，它允许将缓存逻辑与业务代码分离。
