[[cache-declarative-xml]]
= 基于 XML 的声明式缓存

如果注解不是一种选择（可能是由于无法访问源代码或没有外部代码），则可以使用 XML 进行声明式缓存。因此，您可以指定目标方法和外部缓存指令（类似于声明式事务管理 xref:data-access/transaction/declarative/first-example.adoc[建议]），而不是注解缓存方法。上一节中的示例可以转换为以下示例：

[source,xml,indent=0]
[subs="verbatim"]
----
<!-- the service we want to make cacheable -->
<bean id="bookService" class="x.y.service.DefaultBookService"/>

<!-- cache definitions -->
<cache:advice id="cacheAdvice" cache-manager="cacheManager">
  <cache:caching cache="books">
    <cache:cacheable method="findBook" key="#isbn"/>
    <cache:cache-evict method="loadBooks" all-entries="true"/>
  </cache:caching>
</cache:advice>

<!-- apply the cacheable behavior to all BookService interfaces -->
<aop:config>
  <aop:advisor advice-ref="cacheAdvice" pointcut="execution(* x.y.BookService.*(..))"/>
</aop:config>

<!-- cache manager definition omitted -->
----

在前面的配置中，`bookService` 被设为可缓存。要应用的缓存语义封装在 `cache:advice` 定义中，这会导致 `findBooks` 方法用于将数据放入缓存，而 `loadBooks` 方法用于驱逐数据。这两个定义都针对 `books` 缓存工作。

`aop:config` 定义通过使用 AspectJ 切入点表达式将缓存建议应用于程序中的适当点（更多信息可在 xref:core/aop.adoc[Infra 面向切面编程] 中找到）。在前面的示例中，考虑了 `BookService` 中的所有方法，并将缓存建议应用于它们。

声明式 XML 缓存支持所有基于注解的模型，因此在两者之间移动应该相当容易。此外，两者都可以在同一个应用程序中使用。基于 XML 的方法不涉及目标代码。但是，它本来就更冗长。在处理具有针对缓存的重载方法的类时，识别正确的方法确实需要额外的努力，因为 `method` 参数不是一个很好的鉴别器。在这些情况下，您可以使用 AspectJ 切入点来挑选目标方法并应用适当的缓存功能。但是，通过 XML，更容易应用包或组或接口范围的缓存（同样，由于 AspectJ 切入点）并创建类似模板的定义（正如我们在前面的示例中所做的那样，通过 `cache:definitions` `cache` 属性定义目标缓存）。
