[[cache-store-configuration]]
= 缓存存储配置

Infra 的缓存抽象是一个基于接口的机制，它允许你插入任何缓存存储。
核心接口是 `org.springframework.cache.CacheManager` 和 `org.springframework.cache.Cache`。

[[cache-store-configuration-manager]]
== CacheManager

`CacheManager` 是缓存抽象的中心组件。
它负责管理 `Cache` 实例的生命周期，并根据名称检索它们。
Infra 提供了多个 `CacheManager` 实现，包括：

* `SimpleCacheManager`: 用于简单的基于内存的缓存。
* `ConcurrentMapCacheManager`: 使用 `ConcurrentHashMap` 作为后备存储。
* `NoOpCacheManager`: 用于禁用缓存。
* `EhCacheCacheManager`: 用于 Ehcache。
* `JCacheCacheManager`: 用于 JSR-107 兼容的缓存。
* `CaffeineCacheManager`: 用于 Caffeine。
* `RedisCacheManager`: 用于 Redis（通过 Infra Data Redis）。

[[cache-store-configuration-cache]]
== Cache

`Cache` 接口代表一个缓存实例。
它定义了基本的缓存操作，如 `get`、`put`、`evict` 和 `clear`。
大多数用户不需要直接与 `Cache` 接口交互，而是通过 `CacheManager` 或注解来使用它。

[[cache-store-configuration-custom]]
== 自定义缓存解析

在某些情况下，你可能需要动态地确定要使用的缓存，或者根据运行时参数解析缓存。
为此，你可以实现 `CacheResolver` 接口。

[source,java,indent=0,subs="verbatim,quotes"]
----
public class RuntimeCacheResolver implements CacheResolver {

    @Override
    public Collection<? extends Cache> resolveCaches(CacheOperationInvocationContext<?> context) {
        // 基于上下文逻辑解析缓存
        return Collections.singleton(cacheManager.getCache("dynamicCache"));
    }
}
----

然后，你可以在缓存注解中引用此解析器：

[source,java,indent=0,subs="verbatim,quotes"]
----
@Cacheable(cacheResolver = "runtimeCacheResolver")
public Book findBook(ISBN isbn) { ... }
----
