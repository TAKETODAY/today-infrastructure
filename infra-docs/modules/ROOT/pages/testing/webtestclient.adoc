[[webtestclient]]
= WebTestClient

`WebTestClient` is an HTTP client designed for testing server applications. It wraps
WebClient and uses it to perform requests
but exposes a testing facade for verifying responses. `WebTestClient` can be used to
perform end-to-end HTTP tests. It can also be used to test Web MVC and Infra WebFlux
applications without a running server via mock server request and response objects.




[[webtestclient-setup]]
== Setup

To set up a `WebTestClient` you need to choose a server setup to bind to. This can be one
of several mock server setup choices or a connection to a live server.



[[webtestclient-controller-config]]
=== Bind to Controller

This setup allows you to test specific controller(s) via mock request and response objects,
without a running server.


[tabs]
======
Java::
+
[source,java,indent=0,subs="verbatim,quotes",role="primary"]
----
WebTestClient client =
    WebTestClient.bindToController(new TestController()).build();
----

======

For Web MVC, use the following which delegates to the
{today-framework-api}/test/web/mockApi/setup/StandaloneMockMvcBuilder.html[StandaloneMockMvcBuilder]
to load infrastructure equivalent to the xref:web/webmvc/mvc-config.adoc[WebMvc Java config],
registers the given controller(s), and creates an instance of
xref:testing/spring-mvc-test-framework.adoc[MockMvc] to handle requests:

[tabs]
======
Java::
+
[source,java,indent=0,subs="verbatim,quotes",role="primary"]
----
WebTestClient client =
    MockMvcWebTestClient.bindToController(new TestController()).build();
----

======



[[webtestclient-context-config]]
=== Bind to `ApplicationContext`

This setup allows you to load Infra configuration with Web MVC or Infra WebFlux
infrastructure and controller declarations and use it to handle requests via mock request
and response objects, without a running server.

For Web MVC, use the following where the Infra `ApplicationContext` is passed to
{today-framework-api}/test/web/mockApi/setup/MockMvcBuilders.html#webAppContextSetup-cn.taketoday.web.context.WebApplicationContext-[MockMvcBuilders.webAppContextSetup]
to create a xref:testing/spring-mvc-test-framework.adoc[MockMvc] instance to handle
requests:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
----
@ExtendWith(InfraExtension.class)
@WebAppConfiguration("classpath:META-INF/web-resources") // <1>
@ContextHierarchy({
  @ContextConfiguration(classes = RootConfig.class),
  @ContextConfiguration(classes = WebConfig.class)
})
class MyTests {

  @Autowired
  WebApplicationContext wac; // <2>

  WebTestClient client;

  @BeforeEach
  void setUp() {
    client = MockMvcWebTestClient.bindToApplicationContext(this.wac).build(); // <3>
  }
}
----
<1> Specify the configuration to load
<2> Inject the configuration
<3> Create the `WebTestClient`


[[webtestclient-fn-config]]
=== Bind to Router Function

This setup allows you to test functional endpoints via
mock request and response objects, without a running server.

For WebFlux, use the following which delegates to `RouterFunctions.toWebHandler` to
create a server setup to handle requests:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
----
RouterFunction<?> route = ...
client = WebTestClient.bindToRouterFunction(route).build();
----

For Web MVC there are currently no options to test
xref:web/webmvc-functional.adoc[WebMvc functional endpoints].



[[webtestclient-server-config]]
=== Bind to Server

This setup connects to a running server to perform full, end-to-end HTTP tests:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
----
	client = WebTestClient.bindToServer().baseUrl("http://localhost:8080").build();
----

[[webtestclient-client-config]]
=== Client Config

In addition to the server setup options described earlier, you can also configure client
options, including base URL, default headers, client filters, and others. These options
are readily available following `bindToServer()`. For all other configuration options,
you need to use `configureClient()` to transition from server to client configuration, as
follows:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
----
client = WebTestClient.bindToController(new TestController())
    .configureClient()
    .baseUrl("/test")
    .build();
----



[[webtestclient-tests]]
== Writing Tests

`WebTestClient` provides an API identical to WebClient
up to the point of performing a request by using `exchange()`. See the
WebClient documentation for examples on how to
prepare a request with any content including form data, multipart data, and more.

After the call to `exchange()`, `WebTestClient` diverges from the `WebClient` and
instead continues with a workflow to verify responses.

To assert the response status and headers, use the following:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
----
client.get().uri("/persons/1")
  .accept(MediaType.APPLICATION_JSON)
  .exchange()
  .expectStatus().isOk()
  .expectHeader().contentType(MediaType.APPLICATION_JSON);
----

If you would like for all expectations to be asserted even if one of them fails, you can
use `expectAll(..)` instead of multiple chained `expect*(..)` calls. This feature is
similar to the _soft assertions_ support in AssertJ and the `assertAll()` support in
JUnit Jupiter.

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
----
client.get().uri("/persons/1")
  .accept(MediaType.APPLICATION_JSON)
  .exchange()
  .expectAll(
    spec -> spec.expectStatus().isOk(),
    spec -> spec.expectHeader().contentType(MediaType.APPLICATION_JSON)
  );
----

You can then choose to decode the response body through one of the following:

* `expectBody(Class<T>)`: Decode to single object.
* `expectBodyList(Class<T>)`: Decode and collect objects to `List<T>`.
* `expectBody()`: Decode to `byte[]` for xref:testing/webtestclient.adoc#webtestclient-json[JSON Content] or an empty body.

And perform assertions on the resulting higher level Object(s):

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
----
	client.get().uri("/persons")
			.exchange()
			.expectStatus().isOk()
			.expectBodyList(Person.class).hasSize(3).contains(person);
----


If the built-in assertions are insufficient, you can consume the object instead and
perform any other assertions:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
----
import cn.taketoday.test.web.reactive.server.expectBody

client.get().uri("/persons/1")
  .exchange()
  .expectStatus().isOk()
  .expectBody(Person.class)
  .consumeWith(result -> {
    // custom assertions (e.g. AssertJ)...
  });
----

Or you can exit the workflow and obtain an `EntityExchangeResult`:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
----
EntityExchangeResult<Person> result = client.get().uri("/persons/1")
    .exchange()
    .expectStatus().isOk()
    .expectBody(Person.class)
    .returnResult();
----


TIP: When you need to decode to a target type with generics, look for the overloaded methods
that accept
{today-framework-api}/core/ParameterizedTypeReference.html[`ParameterizedTypeReference`]
instead of `Class<T>`.



[[webtestclient-no-content]]
=== No Content

If the response is not expected to have content, you can assert that as follows:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
----
client.post().uri("/persons")
    .body(personMono, Person.class)
    .exchange()
    .expectStatus().isCreated()
    .expectBody().isEmpty();
----

If you want to ignore the response content, the following releases the content without
any assertions:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
----
client.get().uri("/persons/123")
    .exchange()
    .expectStatus().isNotFound()
    .expectBody(Void.class);
----


[[webtestclient-json]]
=== JSON Content

You can use `expectBody()` without a target type to perform assertions on the raw
content rather than through higher level Object(s).

To verify the full JSON content with https://jsonassert.skyscreamer.org[JSONAssert]:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
----
client.get().uri("/persons/1")
    .exchange()
    .expectStatus().isOk()
    .expectBody()
    .json("{\"name\":\"Jane\"}")
----


To verify JSON content with https://github.com/jayway/JsonPath[JSONPath]:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
----
client.get().uri("/persons")
    .exchange()
    .expectStatus().isOk()
    .expectBody()
    .jsonPath("$[0].name").isEqualTo("Jane")
    .jsonPath("$[1].name").isEqualTo("Jason");
----



[[webtestclient-stream]]
=== Streaming Responses

To test potentially infinite streams such as `"text/event-stream"` or
`"application/x-ndjson"`, start by verifying the response status and headers, and then
obtain a `FluxExchangeResult`:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
----
FluxExchangeResult<MyEvent> result = client.get().uri("/events")
    .accept(TEXT_EVENT_STREAM)
    .exchange()
    .expectStatus().isOk()
    .returnResult(MyEvent.class);

----


Now you're ready to consume the response stream with `StepVerifier` from `reactor-test`:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
----
Flux<Event> eventFlux = result.getResponseBody();

StepVerifier.create(eventFlux)
    .expectNext(person)
    .expectNextCount(4)
    .consumeNextWith(p -> ...)
    .thenCancel()
    .verify();
----


[[webtestclient-mockmvc]]
=== MockMvc Assertions

`WebTestClient` is an HTTP client and as such it can only verify what is in the client
response including status, headers, and body.

When testing a Web MVC application with a MockMvc server setup, you have the extra
choice to perform further assertions on the server response. To do that start by
obtaining an `ExchangeResult` after asserting the body:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
----
// For a response with a body
EntityExchangeResult<Person> result = client.get().uri("/persons/1")
    .exchange()
    .expectStatus().isOk()
    .expectBody(Person.class)
    .returnResult();

// For a response without a body
EntityExchangeResult<Void> result = client.get().uri("/path")
    .exchange()
    .expectBody().isEmpty();
----

Then switch to MockMvc server response assertions:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
----
MockMvcWebTestClient.resultActionsFor(result)
    .andExpect(model().attribute("integer", 3))
    .andExpect(model().attribute("string", "a string value"));
----


