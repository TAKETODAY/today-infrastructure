[[aop-proxying]]
= 代理机制

Infra AOP 使用 JDK 动态代理或 CGLIB 来为给定的目标对象创建代理。
JDK 动态代理内置于 JDK 中，而 CGLIB 是一个通用的开源类定义库
（已重新打包到 `infra-core` 中）。

如果被代理的目标对象实现了至少一个接口，则使用 JDK 动态代理。
目标类型实现的所有接口都会被代理。如果目标对象没有实现任何接口，
则会创建 CGLIB 代理。

如果你想强制使用 CGLIB 代理（例如，为了代理目标对象定义的所有方法，
而不仅仅是接口实现的方法），也是可以的。但是，你需要考虑以下问题：

* 使用 CGLIB 时，`final` 方法无法被通知，因为它们不能在运行时生成的子类中被覆盖。
* 从 Infra 4.0 开始，被代理对象的构造函数不再被调用两次，因为 CGLIB 代理实例是通过
  Objenesis 创建的。只有当你的 JVM 不允许绕过构造函数时，才可能看到双重调用
  以及来自 Infra AOP 支持的相应调试日志条目。

要强制使用 CGLIB 代理，请将 `<aop:config>` 元素的 `proxy-target-class` 属性值
设置为 true，如下所示：

[source,xml,indent=0,subs="verbatim"]
----
<aop:config proxy-target-class="true">
  <!-- 此处定义其他 bean... -->
</aop:config>
----

要在使用 @AspectJ 自动代理支持时强制使用 CGLIB 代理，请将 `<aop:aspectj-autoproxy>`
元素的 `proxy-target-class` 属性设置为 `true`，如下所示：

[source,xml,indent=0,subs="verbatim"]
----
<aop:aspectj-autoproxy proxy-target-class="true"/>
----

[NOTE]
====
多个 `<aop:config/>` 部分在运行时会被合并为单个统一的自动代理创建器，
它应用任何 `<aop:config/>` 部分（通常来自不同的 XML bean 定义文件）
中指定的_最强_代理设置。这也适用于 `<tx:annotation-driven/>` 和
`<aop:aspectj-autoproxy/>` 元素。

明确地说，在 `<tx:annotation-driven/>`、`<aop:aspectj-autoproxy/>`
或 `<aop:config/>` 元素上使用 `proxy-target-class="true"` 会强制
_所有这三个_都使用 CGLIB 代理。
====



[[aop-understanding-aop-proxies]]
== 理解 AOP 代理

Infra AOP 是基于代理的。在编写你自己的切面或使用 TODAY Framework 提供的任何
基于 Infra AOP 的切面之前，掌握这句话的实际语义至关重要。

首先考虑这样一种场景：你有一个普通的、未被代理的、毫无特殊之处的直接对象引用，
如下面的代码片段所示：

[tabs]
======
Java::
+
[source,java,indent=0,subs="verbatim",role="primary"]
----
public class SimplePojo implements Pojo {

  public void foo() {
    // 下一个方法调用是直接在 'this' 引用上调用的
    this.bar();
  }

  public void bar() {
    // 一些逻辑...
  }
}
----

======

如果你在对象引用上调用方法，该方法将直接在该对象引用上调用，如下图和清单所示：

image::aop-proxy-plain-pojo-call.png[]

[tabs]
======
Java::
+
[source,java,indent=0,subs="verbatim",role="primary"]
----
public class Main {

  public static void main(String[] args) {
    Pojo pojo = new SimplePojo();
    // 这是在 'pojo' 引用上的直接方法调用
    pojo.foo();
  }
}
----

======

当客户端代码持有的引用是代理时，情况会略有变化。考虑下面的图和代码片段：

image::aop-proxy-call.png[]

[tabs]
======
Java::
+
[source,java,indent=0,subs="verbatim",role="primary"]
----
public class Main {

  public static void main(String[] args) {
    ProxyFactory factory = new ProxyFactory(new SimplePojo());
    factory.addInterface(Pojo.class);
    factory.addAdvice(new RetryAdvice());

    Pojo pojo = (Pojo) factory.getProxy();
    // 这是在代理上的方法调用！
    pojo.foo();
  }
}
----

======

这里需要理解的关键是，`Main` 类的 `main(..)` 方法中的客户端代码持有的是对代理的引用。
这意味着该对象引用上的方法调用是对代理的调用。因此，代理可以委托给与该特定方法调用相关的所有拦截器（通知）。
然而，一旦调用最终到达目标对象（在本例中为 `SimplePojo` 引用），它对自己进行的任何方法调用，
例如 `this.bar()` 或 `this.foo()`，都将针对 `this` 引用调用，而不是针对代理。
这具有重要的含义。这意味着自调用不会导致与方法调用关联的通知有机会运行。

那么，该怎么办呢？最好的方法（这里“最好”一词用得比较宽泛）是重构你的代码，使自调用不再发生。
这确实需要你做一些工作，但这是最好、侵入性最小的方法。下一种方法绝对是糟糕透顶的，
我们犹豫是否要指出它，正是因为它太糟糕了。你可以（尽管这让我们很痛苦）将类中的逻辑完全绑定到
Infra AOP，如下例所示：

[tabs]
======
Java::
+
[source,java,indent=0,subs="verbatim",role="primary"]
----
public class SimplePojo implements Pojo {

  public void foo() {
    // 这行得通，但是... 哎呀！
    ((Pojo) AopContext.currentProxy()).bar();
  }

  public void bar() {
    // 一些逻辑...
  }
}
----
======

这完全将你的代码与 Infra AOP 耦合在一起，并且使类本身意识到它正在 AOP 上下文中使用，
这与 AOP 的初衷背道而驰。在创建代理时，它还需要一些额外的配置，如下例所示：

[tabs]
======
Java::
+
[source,java,indent=0,subs="verbatim",role="primary"]
----
public class Main {

  public static void main(String[] args) {
    ProxyFactory factory = new ProxyFactory(new SimplePojo());
    factory.addInterface(Pojo.class);
    factory.addAdvice(new RetryAdvice());
    factory.setExposeProxy(true);

    Pojo pojo = (Pojo) factory.getProxy();
    // 这是在代理上的方法调用！
    pojo.foo();
  }
}
----

======

最后，必须指出的是，AspectJ 没有这个自调用问题，因为它不是基于代理的 AOP 框架。
