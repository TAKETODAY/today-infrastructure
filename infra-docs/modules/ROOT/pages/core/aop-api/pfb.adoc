[[aop-pfb]]
= 使用 `ProxyFactoryBean` 创建 AOP 代理

如果您为业务对象使用 Infra IoC 容器（`ApplicationContext` 或 `BeanFactory`）（您应该这样做！），您会希望使用 Infra AOP `FactoryBean` 实现之一。（请记住，工厂 bean 引入了一个间接层，让它创建不同类型的对象。）

NOTE: Infra AOP 支持也在幕后使用工厂 bean。

在 Infra 中创建 AOP 代理的基本方法是使用 `infra.aop.framework.ProxyFactoryBean`。这可以完全控制切入点、任何适用的通知及其顺序。但是，如果您不需要此类控制，则有更简单的选项可供选择。



[[aop-pfb-1]]
== 基础

与其他 Infra `FactoryBean` 实现一样，`ProxyFactoryBean` 引入了一个间接级别。如果您定义一个名为 `foo` 的 `ProxyFactoryBean`，则引用 `foo` 的对象看到的不是 `ProxyFactoryBean` 实例本身，而是由 `ProxyFactoryBean` 中的 `getObject()` 方法实现创建的对象。此方法创建一个包装目标对象的 AOP 代理。

使用 `ProxyFactoryBean` 或其他具有 IoC 感知的类来创建 AOP 代理的最重要好处之一是，通知和切入点也可以由 IoC 管理。这是一个强大的功能，可以实现其他 AOP 框架难以实现的方法。例如，通知本身可以引用应用程序对象（除了目标，这在任何 AOP 框架中都应该是可用的），从而受益于依赖注入提供的所有可插拔性。



[[aop-pfb-2]]
== JavaBean 属性

与 Infra 提供的大多数 `FactoryBean` 实现一样，`ProxyFactoryBean` 类本身就是一个 JavaBean。其属性用于：

* 指定要代理的目标。
* 指定是否使用 CGLIB（稍后描述，另请参阅 xref:core/aop-api/pfb.adoc#aop-pfb-proxy-types[基于 JDK 和 CGLIB 的代理]）。

一些关键属性继承自 `infra.aop.framework.ProxyConfig`（Infra 中所有 AOP 代理工厂的超类）。这些关键属性包括：

* `proxyTargetClass`：如果要代理目标类而不是目标类的接口，则为 `true`。如果将此属性值设置为 `true`，则会创建 CGLIB 代理（但另请参阅 xref:core/aop-api/pfb.adoc#aop-pfb-proxy-types[基于 JDK 和 CGLIB 的代理]）。
* `optimize`：控制是否对通过 CGLIB 创建的代理应用激进的优化。除非您完全了解相关 AOP 代理如何处理优化，否则不应轻易使用此设置。这目前仅用于 CGLIB 代理。它对 JDK 动态代理没有影响。
* `frozen`：如果代理配置被 `frozen`，则不再允许更改配置。这既可用作轻微的优化，也适用于您不希望调用者在创建代理后（通过 `Advised` 接口）操作代理的情况。此属性的默认值为 `false`，因此允许更改（例如添加其他通知）。
* `exposeProxy`：确定当前代理是否应在 `ThreadLocal` 中公开，以便目标可以访问它。如果目标需要获取代理并且 `exposeProxy` 属性设置为 `true`，则目标可以使用 `AopContext.currentProxy()` 方法。

特定于 `ProxyFactoryBean` 的其他属性包括：

* `proxyInterfaces`：`String` 接口名称数组。如果未提供此项，则使用目标类的 CGLIB 代理（但另请参阅 xref:core/aop-api/pfb.adoc#aop-pfb-proxy-types[基于 JDK 和 CGLIB 的代理]）。
* `interceptorNames`：要应用的 `Advisor`、拦截器或其他通知名称的 `String` 数组。顺序很重要，遵循先到先得的原则。也就是说，列表中的第一个拦截器是第一个能够拦截调用的拦截器。
+
这些名称是当前工厂中的 bean 名称，包括来自祖先工厂的 bean 名称。您不能在此处提及 bean 引用，因为这样做会导致 `ProxyFactoryBean` 忽略通知的单例设置。
+
您可以在拦截器名称后附加星号（`*`）。这样做会导致应用名称以星号之前的部分开头的所有 advisor bean。您可以在 xref:core/aop-api/pfb.adoc#aop-global-advisors[使用“`全局`”Advisor] 中找到使用此功能的示例。

* singleton：无论调用 `getObject()` 方法多少次，工厂是否都应返回单个对象。几个 `FactoryBean` 实现都提供了这种方法。默认值为 `true`。如果您想使用有状态通知 - 例如，对于有状态 mixin - 请使用原型通知以及单例值为 `false`。



[[aop-pfb-proxy-types]]
== 基于 JDK 和 CGLIB 的代理

本节作为关于 `ProxyFactoryBean` 如何选择为特定目标对象（要代理的对象）创建基于 JDK 的代理或基于 CGLIB 的代理的权威文档。

NOTE: `ProxyFactoryBean` 在创建基于 JDK 或 CGLIB 的代理方面的行为在 Infra 的 1.2.x 和 2.0 版本之间发生了变化。`ProxyFactoryBean` 现在在自动检测接口方面表现出与 `TransactionProxyFactoryBean` 类相似的语义。

如果要代理的目标对象的类（以下简称为目标类）未实现任何接口，则会创建基于 CGLIB 的代理。这是最简单的场景，因为 JDK 代理是基于接口的，没有接口意味着甚至无法进行 JDK 代理。您可以插入目标 bean 并通过设置 `interceptorNames` 属性指定拦截器列表。请注意，即使 `ProxyFactoryBean` 的 `proxyTargetClass` 属性已设置为 `false`，也会创建基于 CGLIB 的代理。（这样做毫无意义，最好从 bean 定义中删除，因为它充其量是多余的，最坏的情况是令人困惑。）

如果目标类实现了一个（或多个）接口，则创建的代理类型取决于 `ProxyFactoryBean` 的配置。

如果 `ProxyFactoryBean` 的 `proxyTargetClass` 属性已设置为 `true`，则会创建基于 CGLIB 的代理。这很有意义，并且符合最小惊讶原则。即使 `ProxyFactoryBean` 的 `proxyInterfaces` 属性已设置为一个或多个完全限定的接口名称，`proxyTargetClass` 属性设置为 `true` 的事实也会导致基于 CGLIB 的代理生效。

如果 `ProxyFactoryBean` 的 `proxyInterfaces` 属性已设置为一个或多个完全限定的接口名称，则会创建基于 JDK 的代理。创建的代理实现了 `proxyInterfaces` 属性中指定的所有接口。如果目标类恰好实现了比 `proxyInterfaces` 属性中指定的接口多得多的接口，那也没关系，但返回的代理不会实现这些额外的接口。

如果未设置 `ProxyFactoryBean` 的 `proxyInterfaces` 属性，但目标类确实实现了一个（或多个）接口，则 `ProxyFactoryBean` 会自动检测到目标类实际上至少实现了一个接口的事实，并创建一个基于 JDK 的代理。实际代理的接口是目标类实现的所有接口。实际上，这与向 `proxyInterfaces` 属性提供目标类实现的每个接口的列表相同。但是，它的工作量要少得多，而且不太容易出现拼写错误。



[[aop-api-proxying-intf]]
== 代理接口

考虑一个 `ProxyFactoryBean` 的简单示例。此示例涉及：

* 一个被代理的目标 bean。这是示例中的 `personTarget` bean 定义。
* 用于提供通知的 `Advisor` 和 `Interceptor`。
* 一个 AOP 代理 bean 定义，用于指定目标对象（`personTarget` bean）、要代理的接口以及要应用的通知。

以下清单显示了该示例：

[source,xml,indent=0,subs="verbatim,quotes"]
----
<bean id="personTarget" class="com.mycompany.PersonImpl">
  <property name="name" value="Tony"/>
  <property name="age" value="51"/>
</bean>

<bean id="myAdvisor" class="com.mycompany.MyAdvisor">
  <property name="someProperty" value="Custom string property value"/>
</bean>

<bean id="debugInterceptor" class="infra.aop.interceptor.DebugInterceptor">
</bean>

<bean id="person"
  class="infra.aop.framework.ProxyFactoryBean">
  <property name="proxyInterfaces" value="com.mycompany.Person"/>

  <property name="target" ref="personTarget"/>
  <property name="interceptorNames">
    <list>
      <value>myAdvisor</value>
      <value>debugInterceptor</value>
    </list>
  </property>
</bean>
----

请注意，`interceptorNames` 属性采用 `String` 列表，其中包含当前工厂中拦截器或 advisor 的 bean 名称。您可以使用 advisor、拦截器、前置、返回后和抛出通知对象。advisor 的顺序很重要。

NOTE: 您可能想知道为什么列表不包含 bean 引用。其原因是，如果 `ProxyFactoryBean` 的 singleton 属性设置为 `false`，它必须能够返回独立的代理实例。如果任何 advisor 本身是原型的，则需要返回一个独立的实例，因此必须能够从工厂获取原型的实例。持有引用是不够的。

前面显示的 `person` bean 定义可以用来代替 `Person` 实现，如下所示：

[tabs]
======
Java::
+
[source,java,indent=0,subs="verbatim,quotes",role="primary"]
----
