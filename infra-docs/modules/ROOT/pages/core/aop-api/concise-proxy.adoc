[[aop-concise-proxy]]
= 简洁的代理定义

特别是当定义事务代理时，你可能最终会得到许多相似的代理定义。
使用父和子 bean 定义以及内部 bean 定义，可以产生更清晰、更简洁的代理定义。

首先，我们为代理创建一个父、模板 bean 定义，如下所示：

[source,xml,indent=0,subs="verbatim,quotes"]
----
<bean id="txProxyTemplate" abstract="true"
    class="infra.transaction.interceptor.TransactionProxyFactoryBean">
  <property name="transactionManager" ref="transactionManager"/>
  <property name="transactionAttributes">
    <props>
      <prop key="*">PROPAGATION_REQUIRED</prop>
    </props>
  </property>
</bean>
----

这本身永远不会被实例化，所以它实际上可能是不完整的。
然后，需要创建的每个代理都是一个子 bean 定义，它将代理的目标包装为内部 bean 定义，因为目标无论如何都不会单独使用。
以下示例显示了这样一个子 bean：

[source,xml,indent=0,subs="verbatim,quotes"]
----
<bean id="myService" parent="txProxyTemplate">
  <property name="target">
    <bean class="infra.samples.MyServiceImpl">
    </bean>
  </property>
</bean>
----

你可以覆盖父模板中的属性。在以下示例中，我们覆盖了事务传播设置：

[source,xml,indent=0,subs="verbatim,quotes"]
----
<bean id="mySpecialService" parent="txProxyTemplate">
  <property name="target">
    <bean class="infra.samples.MySpecialServiceImpl">
    </bean>
  </property>
  <property name="transactionAttributes">
    <props>
      <prop key="get*">PROPAGATION_REQUIRED,readOnly</prop>
      <prop key="find*">PROPAGATION_REQUIRED,readOnly</prop>
      <prop key="load*">PROPAGATION_REQUIRED,readOnly</prop>
      <prop key="store*">PROPAGATION_REQUIRED</prop>
    </props>
  </property>
</bean>
----

请注意，在父 bean 示例中，我们将父 bean 定义显式标记为抽象，通过将 `abstract` 属性设置为 `true`，
如 xref:core/beans/child-bean-definitions.adoc[前文] 所述，以便它实际上永远不会被实例化。
默认情况下，应用程序上下文（而非简单的 bean 工厂）会预实例化所有单例。
因此，重要的是（至少对于单例 bean），如果你有一个（父）bean 定义，你打算仅将其用作模板，并且此定义指定了一个类，
你必须确保将 `abstract` 属性设置为 `true`。否则，应用程序上下文实际上会尝试预实例化它。
