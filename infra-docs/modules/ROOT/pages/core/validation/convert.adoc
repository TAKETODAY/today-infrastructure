[[core-convert]]
= Infra 类型转换

`core.convert` 包提供了一个通用的类型转换系统。该系统定义了一个用于实现类型转换逻辑的 SPI 和一个用于在运行时执行类型转换的 API。在 Infra 容器中，您可以使用此系统作为 `PropertyEditor` 实现的替代方案，将外部化的 bean 属性值字符串转换为所需的属性类型。您还可以在应用程序中需要类型转换的任何地方使用公共 API。



[[core-convert-Converter-API]]
== Converter SPI

用于实现类型转换逻辑的 SPI 简单且是强类型的，如下接口定义所示：

[source,java,indent=0,subs="verbatim,quotes",chomp="-packages"]
----
package infra.core.convert.converter;

public interface Converter<S, T> {

  T convert(S source);
}
----

要创建自己的转换器，请实现 `Converter` 接口，并将 `S` 参数化为您要转换的类型，将 `T` 参数化为您要转换到的类型。如果还需要将 `S` 的集合或数组转换为 `T` 的数组或集合，只要已注册了委托数组或集合转换器（`DefaultConversionService` 默认会这样做），您也可以透明地应用此类转换器。

对于每次 `convert(S)` 调用，源参数保证不为 null。如果转换失败，您的 `Converter` 可能会抛出任何非受检异常。具体来说，它应该抛出 `IllegalArgumentException` 以报告无效的源值。
请注意确保您的 `Converter` 实现是线程安全的。

`core.convert.support` 包中提供了几个转换器实现以方便使用。其中包括从字符串到数字和其他常见类型的转换器。
以下列表显示了 `StringToInteger` 类，这是一个典型的 `Converter` 实现：

[source,java,indent=0,subs="verbatim,quotes",chomp="-packages"]
----
package infra.core.convert.support;

final class StringToInteger implements Converter<String, Integer> {

  public Integer convert(String source) {
    return Integer.valueOf(source);
  }
}
----



[[core-convert-ConverterFactory-SPI]]
== 使用 `ConverterFactory`

当您需要集中整个类层次结构的转换逻辑时（例如，从 `String` 转换为 `Enum` 对象时），可以实现 `ConverterFactory`，如下例所示：

[source,java,indent=0,subs="verbatim,quotes",chomp="-packages"]
----
package infra.core.convert.converter;

public interface ConverterFactory<S, R> {

  <T extends R> Converter<S, T> getConverter(Class<T> targetType);
}
----

将 S 参数化为您要转换的类型，将 R 参数化为定义您可以转换到的类__范围__的基类型。然后实现 `getConverter(Class<T>)`，其中 T 是 R 的子类。

以 `StringToEnumConverterFactory` 为例：

[source,java,indent=0,subs="verbatim,quotes",chomp="-packages"]
----
package infra.core.convert.support;

final class StringToEnumConverterFactory implements ConverterFactory<String, Enum> {

  public <T extends Enum> Converter<String, T> getConverter(Class<T> targetType) {
    return new StringToEnumConverter(targetType);
  }

  private final class StringToEnumConverter<T extends Enum> implements Converter<String, T> {

    private Class<T> enumType;

    public StringToEnumConverter(Class<T> enumType) {
      this.enumType = enumType;
    }

    public T convert(String source) {
      return (T) Enum.valueOf(this.enumType, source.trim());
    }
  }
}
----


[[core-convert-GenericConverter-SPI]]
== 使用 `GenericConverter`

当您需要复杂的 `Converter` 实现时，请考虑使用 `GenericConverter` 接口。`GenericConverter` 具有比 `Converter` 更灵活但不那么强类型的签名，支持在多种源类型和目标类型之间进行转换。此外，`GenericConverter` 提供了可用的源和目标字段上下文，您可以在实现转换逻辑时使用该上下文。此类上下文允许类型转换由字段注解或字段签名上声明的泛型信息驱动。以下列表显示了 `GenericConverter` 的接口定义：

[source,java,indent=0,subs="verbatim,quotes",chomp="-packages"]
----
package infra.core.convert.converter;

public interface GenericConverter {

  public Set<ConvertiblePair> getConvertibleTypes();

  Object convert(Object source, TypeDescriptor sourceType, TypeDescriptor targetType);
}
----

要实现 `GenericConverter`，请让 `getConvertibleTypes()` 返回支持的源->目标类型对。然后实现 `convert(Object, TypeDescriptor, TypeDescriptor)` 以包含您的转换逻辑。源 `TypeDescriptor` 提供对保存要转换的值的源字段的访问。目标 `TypeDescriptor` 提供对要设置转换值的目标字段的访问。

`GenericConverter` 的一个很好的例子是在 Java 数组和集合之间进行转换的转换器。此类 `ArrayToCollectionConverter` 会内省声明目标集合类型的字段，以解析集合的元素类型。这使得源数组中的每个元素在将集合设置到目标字段之前，都可以转换为集合元素类型。

注意：由于 `GenericConverter` 是一个更复杂的 SPI 接口，因此只有在需要时才应使用它。对于基本类型转换需求，请优先使用 `Converter` 或 `ConverterFactory`。


[[core-convert-ConditionalGenericConverter-SPI]]
=== 使用 `ConditionalGenericConverter`

有时，您希望 `Converter` 仅在特定条件成立时才运行。例如，您可能希望仅当目标字段上存在特定注解时才运行 `Converter`，或者仅当目标类上定义了特定方法（例如 `static valueOf` 方法）时才运行 `Converter`。
`ConditionalGenericConverter` 是 `GenericConverter` 和 `ConditionalConverter` 接口的并集，允许您定义此类自定义匹配条件：

[source,java,indent=0,subs="verbatim,quotes"]
----
public interface ConditionalConverter {

  boolean matches(TypeDescriptor sourceType, TypeDescriptor targetType);
}

public interface ConditionalGenericConverter extends GenericConverter, ConditionalConverter {
}
----

`ConditionalGenericConverter` 的一个很好的例子是 `IdToEntityConverter`，它在持久化实体标识符和实体引用之间进行转换。此类 `IdToEntityConverter` 可能仅在目标实体类型声明了静态查找器方法（例如 `findAccount(Long)`）时才匹配。您可以在 `matches(TypeDescriptor, TypeDescriptor)` 的实现中执行此类查找器方法检查。



[[core-convert-ConversionService-API]]
== `ConversionService` API

`ConversionService` 定义了一个统一的 API，用于在运行时执行类型转换逻辑。转换器通常在以下外观接口后面运行：

[source,java,indent=0,subs="verbatim,quotes",chomp="-packages"]
----
package infra.core.convert;

public interface ConversionService {

  boolean canConvert(Class<?> sourceType, Class<?> targetType);

  <T> T convert(Object source, Class<T> targetType);

  boolean canConvert(TypeDescriptor sourceType, TypeDescriptor targetType);

  Object convert(Object source, TypeDescriptor sourceType, TypeDescriptor targetType);
}
----

大多数 `ConversionService` 实现还实现了 `ConverterRegistry`，它提供了一个用于注册转换器的 SPI。在内部，`ConversionService` 实现委托给其注册的转换器来执行类型转换逻辑。
