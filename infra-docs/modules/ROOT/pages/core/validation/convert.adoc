[[core-convert]]
= Infra 类型转换

`core.convert` 包提供了一个通用的类型转换系统。该系统定义了一个 SPI 来实现类型转换逻辑，并定义了一个 API 来在运行时执行类型转换。在 Infra 容器中，您可以使用此系统作为 `PropertyEditor` 实现的替代方案，将外部化的 bean 属性值字符串转换为所需的属性类型。您还可以在应用程序中需要类型转换的任何地方使用公共 API。



[[core-convert-Converter-API]]
== Converter SPI

用于实现类型转换逻辑的 SPI 简单且强类型化，如下面的接口定义所示：

[source,java,indent=0,subs="verbatim,quotes",chomp="-packages"]
----
package infra.core.convert.converter;

public interface Converter<S, T> {

  T convert(S source);
}
----

要创建自己的转换器，请实现 `Converter` 接口，并将 `S` 参数化为您要转换的类型，将 `T` 参数化为您要转换到的类型。如果需要将 `S` 的集合或数组转换为 `T` 的数组或集合，只要还注册了委托数组或集合转换器（`DefaultConversionService` 默认会这样做），您也可以透明地应用此类转换器。

对于每次 `convert(S)` 调用，源参数保证不为空。如果转换失败，您的 `Converter` 可能会抛出任何非检查异常。具体来说，它应该抛出 `IllegalArgumentException` 来报告无效的源值。
请务必确保您的 `Converter` 实现是线程安全的。

`core.convert.support` 包中提供了几个转换器实现以方便使用。其中包括从字符串到数字和其他常见类型的转换器。
以下清单显示了 `StringToInteger` 类，这是一个典型的 `Converter` 实现：

[source,java,indent=0,subs="verbatim,quotes",chomp="-packages"]
----
package infra.core.convert.support;

final class StringToInteger implements Converter<String, Integer> {

  public Integer convert(String source) {
    return Integer.valueOf(source);
  }
}
----



[[core-convert-ConverterFactory-SPI]]
== 使用 `ConverterFactory`

当您需要集中整个类层次结构的转换逻辑时（例如，从 `String` 转换为 `Enum` 对象时），您可以实现 `ConverterFactory`，如下例所示：

[source,java,indent=0,subs="verbatim,quotes",chomp="-packages"]
----
package infra.core.convert.converter;

public interface ConverterFactory<S, R> {

  <T extends R> Converter<S, T> getConverter(Class<T> targetType);
}
----

将 S 参数化为您要转换的类型，将 R 参数化为定义您可以转换到的类__范围__的基类型。然后实现 `getConverter(Class<T>)`，其中 T 是 R 的子类。

以 `StringToEnumConverterFactory` 为例：

[source,java,indent=0,subs="verbatim,quotes",chomp="-packages"]
----
package infra.core.convert.support;

final class StringToEnumConverterFactory implements ConverterFactory<String, Enum> {

  public <T extends Enum> Converter<String, T> getConverter(Class<T> targetType) {
    return new StringToEnumConverter(targetType);
  }

  private final class StringToEnumConverter<T extends Enum> implements Converter<String, T> {

    private Class<T> enumType;

    public StringToEnumConverter(Class<T> enumType) {
      this.enumType = enumType;
    }

    public T convert(String source) {
      return (T) Enum.valueOf(this.enumType, source.trim());
    }
  }
}
----


[[core-convert-GenericConverter-SPI]]
== 使用 `GenericConverter`

当您需要复杂的 `Converter` 实现时，请考虑使用 `GenericConverter` 接口。`GenericConverter` 具有比 `Converter` 更灵活但类型不那么强的签名，支持在多种源类型和目标类型之间进行转换。此外，`GenericConverter` 提供了可用的源和目标字段上下文，您可以在实现转换逻辑时使用这些上下文。此类上下文允许类型转换由字段注解或字段签名上声明的泛型信息驱动。以下清单显示了 `GenericConverter` 的接口定义：

[source,java,indent=0,subs="verbatim,quotes",chomp="-packages"]
----
package infra.core.convert.converter;

public interface GenericConverter {

  public Set<ConvertiblePair> getConvertibleTypes();

  Object convert(Object source, TypeDescriptor sourceType, TypeDescriptor targetType);
}
----

要实现 `GenericConverter`，请让 `getConvertibleTypes()` 返回支持的源->目标类型对。然后实现 `convert(Object, TypeDescriptor, TypeDescriptor)` 以包含您的转换逻辑。源 `TypeDescriptor` 提供对保存正在转换的值的源字段的访问。目标 `TypeDescriptor` 提供对要设置转换值的目标字段的访问。

`GenericConverter` 的一个很好的例子是在 Java 数组和集合之间进行转换的转换器。此类 `ArrayToCollectionConverter` 会内省声明目标集合类型的字段以解析集合的元素类型。这允许在将集合设置在目标字段上之前，将源数组中的每个元素转换为集合元素类型。

NOTE: 由于 `GenericConverter` 是一个更复杂的 SPI 接口，因此您应该只在需要时使用它。对于基本类型转换需求，请首选 `Converter` 或 `ConverterFactory`。


[[core-convert-ConditionalGenericConverter-SPI]]
=== 使用 `ConditionalGenericConverter`

有时，您只希望在特定条件成立时运行 `Converter`。例如，您可能只想在目标字段上存在特定注解时运行 `Converter`，或者只想在目标类上定义了特定方法（例如 `static valueOf` 方法）时运行 `Converter`。
`ConditionalGenericConverter` 是 `GenericConverter` 和 `ConditionalConverter` 接口的联合，允许您定义此类自定义匹配条件：

[source,java,indent=0,subs="verbatim,quotes"]
----
public interface ConditionalConverter {

  boolean matches(TypeDescriptor sourceType, TypeDescriptor targetType);
}

public interface ConditionalGenericConverter extends GenericConverter, ConditionalConverter {
}
----

`ConditionalGenericConverter` 的一个很好的例子是 `IdToEntityConverter`，它在持久实体标识符和实体引用之间进行转换。此类 `IdToEntityConverter` 可能仅在目标实体类型声明静态查找器方法（例如 `findAccount(Long)`）时才匹配。您可以在 `matches(TypeDescriptor, TypeDescriptor)` 的实现中执行此类查找器方法检查。



[[core-convert-ConversionService-API]]
== `ConversionService` API

`ConversionService` 定义了一个统一的 API，用于在运行时执行类型转换逻辑。转换器通常在以下外观接口后面运行：

[source,java,indent=0,subs="verbatim,quotes",chomp="-packages"]
----
package infra.core.convert;

public interface ConversionService {

  boolean canConvert(Class<?> sourceType, Class<?> targetType);

  <T> T convert(Object source, Class<T> targetType);

  boolean canConvert(TypeDescriptor sourceType, TypeDescriptor targetType);

  Object convert(Object source, TypeDescriptor sourceType, TypeDescriptor targetType);
}
----

大多数 `ConversionService` 实现还实现了 `ConverterRegistry`，它提供了一个用于注册转换器的 SPI。在内部，`ConversionService` 实现委托给其注册的转换器来执行类型转换逻辑。

`core.convert.support` 包中提供了一个健壮的 `ConversionService` 实现。`GenericConversionService` 是适用于大多数环境的通用实现。`ConversionServiceFactory` 提供了一个方便的工厂来创建常见的 `ConversionService` 配置。



[[core-convert-Infra-config]]
== 配置 `ConversionService`

`ConversionService` 是一个无状态对象，设计为在应用程序启动时实例化，然后在多个线程之间共享。在 Infra 应用程序中，您通常为每个 Infra 容器（或 `ApplicationContext`）配置一个 `ConversionService` 实例。Infra 会获取该 `ConversionService`，并在框架需要执行类型转换时使用它。您还可以将此 `ConversionService` 注入到任何 bean 中并直接调用它。

NOTE: 如果没有向 Infra 注册 `ConversionService`，则使用原本基于 `PropertyEditor` 的系统。

要向 Infra 注册默认的 `ConversionService`，请添加以下 `id` 为 `conversionService` 的 bean 定义：

[source,xml,indent=0,subs="verbatim,quotes"]
----
<bean id="conversionService"
  class="infra.context.support.ConversionServiceFactoryBean"/>
----

默认的 `ConversionService` 可以在字符串、数字、枚举、集合、映射和其他常见类型之间进行转换。要使用您自己的自定义转换器补充或覆盖默认转换器，请设置 `converters` 属性。属性值可以实现 `Converter`、`ConverterFactory` 或 `GenericConverter` 接口中的任何一个。

[source,xml,indent=0,subs="verbatim,quotes"]
----
<bean id="conversionService"
    class="infra.context.support.ConversionServiceFactoryBean">
  <property name="converters">
    <set>
      <bean class="example.MyCustomConverter"/>
    </set>
  </property>
</bean>
----

在 Web MVC 应用程序中使用 `ConversionService` 也很常见。请参阅 Web MVC 章节中的 xref:web/webmvc/mvc-config/conversion.adoc[转换和格式化]。

在某些情况下，您可能希望在转换期间应用格式化。有关使用 `FormattingConversionServiceFactoryBean` 的详细信息，请参阅 xref:core/validation/format.adoc#format-FormatterRegistry-SPI[`FormatterRegistry` SPI]。



[[core-convert-programmatic-usage]]
== 以编程方式使用 `ConversionService`

要以编程方式使用 `ConversionService` 实例，您可以像对待任何其他 bean 一样注入对它的引用。以下示例显示了如何执行此操作：

[tabs]
======
Java::
+
[source,java,indent=0,subs="verbatim,quotes",role="primary"]
----
@Service
public class MyService {

  private final ConversionService conversionService;

  public MyService(ConversionService conversionService) {
    this.conversionService = conversionService;
  }

  public void doIt() {
    this.conversionService.convert(...)
  }
}
----

======

对于大多数用例，您可以使用指定 `targetType` 的 `convert` 方法，但它不适用于更复杂的类型，例如参数化元素的集合。例如，如果您想以编程方式将 `Integer` 的 `List` 转换为 `String` 的 `List`，则需要提供源类型和目标类型的正式定义。

幸运的是，`TypeDescriptor` 提供了各种选项使这变得简单，如下例所示：

[tabs]
======
Java::
+
[source,java,indent=0,subs="verbatim,quotes",role="primary"]
----
DefaultConversionService cs = new DefaultConversionService();

List<Integer> input = ...
cs.convert(input,
  TypeDescriptor.forObject(input), // List<Integer> 类型描述符
  TypeDescriptor.collection(List.class, TypeDescriptor.valueOf(String.class)));
----
======

请注意，`DefaultConversionService` 会自动注册适合大多数环境的转换器。这包括集合转换器、标量转换器和基本的 `Object` 到 `String` 转换器。您可以使用 `DefaultConversionService` 类上的静态 `addDefaultConverters` 方法向任何 `ConverterRegistry` 注册相同的转换器。

值类型的转换器可用于数组和集合，因此无需创建特定的转换器来将 `S` 的 `Collection` 转换为 `T` 的 `Collection`，假设标准集合处理是合适的。
