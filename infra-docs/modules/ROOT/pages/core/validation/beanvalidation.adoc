[[validation-beanvalidation]]
= Java Bean Validation

TODAY Framework 提供了对 {bean-validation-site}[Java Bean Validation] API 的支持。



[[validation-beanvalidation-overview]]
== Bean Validation 概述

Bean Validation 通过约束声明和 Java 应用程序的元数据提供了一种通用的验证方式。要使用它，您可以使用声明性验证约束对领域模型属性进行注解，然后由运行时强制执行这些约束。除了内置约束外，您还可以定义自己的自定义约束。

考虑以下示例，它显示了一个具有两个属性的简单 `PersonForm` 模型：

[tabs]
======
Java::
+
[source,java,indent=0,subs="verbatim,quotes",role="primary"]
----
public class PersonForm {
  private String name;
  private int age;
}
----

======

Bean Validation 允许您声明如下示例所示的约束：

[tabs]
======
Java::
+
[source,java,indent=0,subs="verbatim,quotes",role="primary"]
----
public class PersonForm {

  @NotNull
  @Size(max=64)
  private String name;

  @Min(0)
  private int age;
}
----

======

然后，Bean Validation 验证器会根据声明的约束验证此类的实例。有关 API 的一般信息，请参阅 {bean-validation-site}[Bean Validation]。有关特定约束，请参阅 https://hibernate.org/validator/[Hibernate Validator] 文档。要了解如何将 Bean Validation 提供程序设置为 Infra bean，请继续阅读。



[[validation-beanvalidation-spring]]
== 配置 Bean Validation 提供程序

Infra 提供了对 Bean Validation API 的全面支持，包括将 Bean Validation 提供程序引导为 Infra bean。这使您可以在应用程序中需要验证的任何地方注入 `jakarta.validation.ValidatorFactory` 或 `jakarta.validation.Validator`。

您可以使用 `LocalValidatorFactoryBean` 将默认验证器配置为 Infra bean，如下例所示：

[tabs]
======
Java::
+
[source,java,indent=0,subs="verbatim,quotes",role="primary"]
----
import infra.validation.beanvalidation.LocalValidatorFactoryBean;

@Configuration
public class AppConfig {

  @Bean
  public LocalValidatorFactoryBean validator() {
    return new LocalValidatorFactoryBean();
  }
}
----

XML::
+
[source,xml,indent=0,subs="verbatim,quotes",role="secondary"]
----
<bean id="validator" class="infra.validation.beanvalidation.LocalValidatorFactoryBean"/>
----
======

上例中的基本配置会触发 Bean Validation 使用其默认引导机制进行初始化。Bean Validation 提供程序（如 Hibernate Validator）应存在于类路径中，并将被自动检测到。


[[validation-beanvalidation-infra-inject]]
=== 注入 Jakarta Validator

`LocalValidatorFactoryBean` 实现了 `jakarta.validation.ValidatorFactory` 和 `jakarta.validation.Validator`，因此如果您更喜欢直接使用 Bean Validation API，可以注入后者的引用以应用验证逻辑，如下例所示：

[tabs]
======
Java::
+
[source,java,indent=0,subs="verbatim,quotes",role="primary"]
----
import jakarta.validation.Validator;

@Service
public class MyService {

  @Autowired
  private Validator validator;
}
----

======


[[validation-beanvalidation-infra-inject-adapter]]
=== 注入 Infra Validator

除了实现 `jakarta.validation.Validator` 之外，`LocalValidatorFactoryBean` 还适配了 `infra.validation.Validator`，因此如果您的 bean 需要 Infra Validation API，可以注入后者的引用。

例如：

[tabs]
======
Java::
+
[source,java,indent=0,subs="verbatim,quotes",role="primary"]
----
import infra.validation.Validator;

@Service
public class MyService {

  @Autowired
  private Validator validator;
}
----

======

当用作 `infra.validation.Validator` 时，`LocalValidatorFactoryBean` 会调用底层的 `jakarta.validation.Validator`，然后将 ``ContraintViolation`` 适配为 ``FieldError``，并将其注册到传递给 `validate` 方法的 `Errors` 对象中。



[[validation-beanvalidation-infra-constraints]]
=== 配置自定义约束

每个 Bean Validation 约束由两部分组成：

* 一个 `@Constraint` 注解，声明约束及其可配置属性。
* 一个 `jakarta.validation.ConstraintValidator` 接口的实现，实现约束的行为。

要将声明与实现关联起来，每个 `@Constraint` 注解都引用一个相应的 `ConstraintValidator` 实现类。在运行时，当在您的领域模型中遇到约束注解时，`ConstraintValidatorFactory` 会实例化引用的实现。

默认情况下，`LocalValidatorFactoryBean` 配置了一个 `InfraConstraintValidatorFactory`，它使用 Infra 来创建 `ConstraintValidator` 实例。这使您的自定义 `ConstraintValidator` 可以像任何其他 Infra bean 一样受益于依赖注入。

以下示例显示了一个自定义 `@Constraint` 声明，后跟一个使用 Infra 进行依赖注入的关联 `ConstraintValidator` 实现：

[tabs]
======
Java::
+
[source,java,indent=0,subs="verbatim,quotes",role="primary"]
----
@Target({ElementType.METHOD, ElementType.FIELD})
@Retention(RetentionPolicy.RUNTIME)
@Constraint(validatedBy=MyConstraintValidator.class)
public @interface MyConstraint {
}
----

======
