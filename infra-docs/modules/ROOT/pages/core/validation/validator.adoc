[[validator]]
= 使用 Infra Validator 接口进行验证

Infra 提供了一个 `Validator` 接口，您可以使用它来验证对象。`Validator` 接口通过使用 `Errors` 对象工作，以便在验证时，验证器可以向 `Errors` 对象报告验证失败。

考虑以下一个小数据对象的示例：

[tabs]
======
Java::
+
[source,java,indent=0,subs="verbatim,quotes",role="primary"]
----
public class Person {

  private String name;
  private int age;

  // 通常的 getter 和 setter...
}
----

======

下一个示例通过实现 `infra.validation.Validator` 接口的以下两个方法，为 `Person` 类提供验证行为：

* `supports(Class)`：此 `Validator` 是否可以验证提供的 `Class` 的实例？
* `validate(Object, infra.validation.Errors)`：验证给定的对象，如果出现验证错误，则将其注册到给定的 `Errors` 对象中。

实现 `Validator` 相当简单，尤其是当您知道 TODAY Framework 还提供的 `ValidationUtils` 辅助类时。以下示例为 `Person` 实例实现了 `Validator`：

[tabs]
======
Java::
+
[source,java,indent=0,subs="verbatim,quotes",role="primary"]
----
public class PersonValidator implements Validator {

  /**
   * 此 Validator 仅验证 Person 实例
   */
  public boolean supports(Class clazz) {
    return Person.class.equals(clazz);
  }

  public void validate(Object obj, Errors e) {
    ValidationUtils.rejectIfEmpty(e, "name", "name.empty");
    Person p = (Person) obj;
    if (p.getAge() < 0) {
      e.rejectValue("age", "negativevalue");
    } else if (p.getAge() > 110) {
      e.rejectValue("age", "too.darn.old");
    }
  }
}
----

======

`ValidationUtils` 类上的 `static` `rejectIfEmpty(..)` 方法用于在 `name` 属性为 `null` 或空字符串时拒绝该属性。请查看 {today-framework-api}/validation/ValidationUtils.html[`ValidationUtils`] javadoc，以了解除了前面显示的示例之外，它还提供了哪些功能。

虽然实现单个 `Validator` 类来验证富对象中的每个嵌套对象当然是可能的，但最好将每个嵌套对象类的验证逻辑封装在其自己的 `Validator` 实现中。"`富`"对象的一个简单示例是 `Customer`，它由两个 `String` 属性（名字和姓氏）和一个复杂的 `Address` 对象组成。`Address` 对象可以独立于 `Customer` 对象使用，因此实现了一个独特的 `AddressValidator`。如果您希望您的 `CustomerValidator` 重用 `AddressValidator` 类中包含的逻辑，而不求助于复制和粘贴，您可以在 `CustomerValidator` 中依赖注入或实例化一个 `AddressValidator`，如下例所示：

[tabs]
======
Java::
+
[source,java,indent=0,subs="verbatim,quotes",role="primary"]
----
public class CustomerValidator implements Validator {

  private final Validator addressValidator;

  public CustomerValidator(Validator addressValidator) {
    if (addressValidator == null) {
      throw new IllegalArgumentException("The supplied [Validator] is " +
        "required and must not be null.");
    }
    if (!addressValidator.supports(Address.class)) {
      throw new IllegalArgumentException("The supplied [Validator] must " +
        "support the validation of [Address] instances.");
    }
    this.addressValidator = addressValidator;
  }

  /**
   * 此 Validator 验证 Customer 实例，以及 Customer 的任何子类
   */
  public boolean supports(Class clazz) {
    return Customer.class.isAssignableFrom(clazz);
  }

  public void validate(Object target, Errors errors) {
    ValidationUtils.rejectIfEmptyOrWhitespace(errors, "firstName", "field.required");
    ValidationUtils.rejectIfEmptyOrWhitespace(errors, "surname", "field.required");
    Customer customer = (Customer) target;
    try {
      errors.pushNestedPath("address");
      ValidationUtils.invokeValidator(this.addressValidator, customer.getAddress(), errors);
    } finally {
      errors.popNestedPath();
    }
  }
}
----

======

验证错误将报告给传递给验证器的 `Errors` 对象。在 Infra Web MVC 的情况下，您可以使用 `<spring:bind/>` 标签来检查错误消息，但您也可以自己检查 `Errors` 对象。有关其提供的方法的更多信息，请参阅 {today-framework-api}/validation/Errors.html[javadoc]。

验证器也可以在本地调用，以便立即验证给定对象，而不涉及绑定过程。从 6.1 开始，这已通过一个新的 `Validator.validateObject(Object)` 方法得到简化，该方法现在默认可用，返回一个简单的 `Errors` 表示形式，可以对其进行检查：通常调用 `hasErrors()` 或新的 `failOnError` 方法将错误摘要消息转换为异常（例如 `validator.validateObject(myObject).failOnError(IllegalArgumentException::new)`）。
