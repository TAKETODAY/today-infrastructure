[[expressions-types]]
= 类型

你可以使用特殊的 `T` 运算符来指定 `java.lang.Class`（类型）的实例。
静态方法也通过使用此运算符来调用。
`StandardEvaluationContext` 使用 `TypeLocator` 来查找类型，
而 `StandardTypeLocator`（可以替换）是在了解 `java.lang` 包的情况下构建的。
这意味着对 `java.lang` 包内类型的 `T()` 引用不需要完全限定，但所有其他类型引用必须完全限定。
下例展示了如何使用 `T` 运算符：

[tabs]
======
Java::
+
[source,java,indent=0,subs="verbatim,quotes",role="primary"]
----
Class dateClass = parser.parseExpression("T(java.util.Date)").getValue(Class.class);

Class stringClass = parser.parseExpression("T(String)").getValue(Class.class);

boolean trueValue = parser.parseExpression(
    "T(java.math.RoundingMode).CEILING < T(java.math.RoundingMode).FLOOR")
    .getValue(Boolean.class);
----

======

[NOTE]
====
如果你的应用程序或框架管理自己的 `EvaluationContext`，你可能需要手动配置具有特定 `ClassLoader` 的
`StandardTypeLocator`，以确保 SpEL 表达式解析器能够可靠地定位用户类型。

例如，`spring-context` 模块中的 `StandardBeanExpressionResolver` 使用相应 `BeanFactory` 的 bean `ClassLoader`
配置 `StandardTypeLocator`。
====
