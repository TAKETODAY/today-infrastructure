[[expressions-ref-variables]]
= 变量

你可以使用 `#variableName` 语法在表达式中引用变量。
变量通过使用 `EvaluationContext` 实现中的 `setVariable()` 方法进行设置。

[NOTE]
====
变量名必须以字母（定义如下）、下划线或美元符号开头。

变量名必须由一个或多个以下支持的字符类型组成。

* 字母：任何 `java.lang.Character.isLetter(char)` 返回 `true` 的字符
  - 这包括 `A` 到 `Z`、`a` 到 `z`、`ü`、`ñ` 和 `é` 等字母，以及其他字符集（如中文、日文、西里尔文等）中的字母。
* 数字：`0` 到 `9`
* 下划线：`_`
* 美元符号：`$`
====

[TIP]
====
在 `EvaluationContext` 中设置变量或根上下文对象时，建议变量或根上下文对象的类型为 `public`。

否则，某些涉及非公共类型的变量或根上下文对象的 SpEL 表达式可能无法评估或编译。
====

[WARNING]
====
由于变量与评估上下文中的 xref:core/expressions/language-ref/functions.adoc[函数] 共享一个公共命名空间，
因此必须注意确保变量名和函数名不重叠。
====

下例展示了如何使用变量。

[tabs]
======
Java::
+
[source,java,indent=0,subs="verbatim,quotes",role="primary"]
----
Inventor tesla = new Inventor("Nikola Tesla", "Serbian");

EvaluationContext context = SimpleEvaluationContext.forReadWriteDataBinding().build();
context.setVariable("newName", "Mike Tesla");

parser.parseExpression("name = #newName").getValue(context, tesla);
System.out.println(tesla.getName());  // "Mike Tesla"
----

======


[[expressions-this-root]]
== `#this` 和 `#root` 变量

`#this` 变量始终已定义，并引用当前的评估对象（针对该对象解析非限定引用）。
`#root` 变量始终已定义，并引用根上下文对象。
虽然 `#this` 可能会随着表达式组件的评估而变化，但 `#root` 始终引用根。

下例展示了如何结合 xref:core/expressions/language-ref/collection-selection.adoc[集合选择] 使用 `#this` 变量。

[tabs]
======
Java::
+
[source,java,indent=0,subs="verbatim,quotes",role="primary"]
----
// 创建质数整数列表
List<Integer> primes = List.of(2, 3, 5, 7, 11, 13, 17);

// 创建解析器并将变量 'primes' 设置为整数列表
ExpressionParser parser = new SpelExpressionParser();
EvaluationContext context = SimpleEvaluationContext.forReadWriteDataBinding().build();
context.setVariable("primes", primes);

// 从列表中选择所有大于 10 的质数（使用选择 ?{...}）
String expression = "#primes.?[#this > 10]";

// 评估结果为包含 [11, 13, 17] 的列表
List<Integer> primesGreaterThanTen =
  parser.parseExpression(expression).getValue(context, List.class);
----

======

下例展示了如何结合 xref:core/expressions/language-ref/collection-projection.adoc[集合投影] 一起使用 `#this` 和 `#root` 变量。

[tabs]
======
Java::
+
[source,java,indent=0,subs="verbatim,quotes",role="primary"]
----
// 创建解析器和评估上下文
ExpressionParser parser = new SpelExpressionParser();
EvaluationContext context = SimpleEvaluationContext.forReadWriteDataBinding().build();

// 创建一个发明家作为根上下文对象
Inventor tesla = new Inventor("Nikola Tesla");
tesla.setInventions("Telephone repeater", "Tesla coil transformer");

// 迭代作为 #root 对象引用的发明家的所有发明，
// 并生成一个字符串列表，其内容形式为 "<inventor's name> invented the <invention>."（使用投影 !{...}）
String expression = "#root.inventions.![#root.name + ' invented the ' + #this + '.']";

// 评估结果为包含以下内容的列表：
// "Nikola Tesla invented the Telephone repeater."
// "Nikola Tesla invented the Tesla coil transformer."
List<String> results = parser.parseExpression(expression)
  .getValue(context, tesla, List.class);
----

======
