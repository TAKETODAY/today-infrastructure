[[beans-definition]]
= Bean 概览

Infra IoC 容器管理一个或多个 bean。这些 bean 是根据您提供给容器的配置元数据（例如，以 XML `<bean/>` 定义的形式）创建的。

在容器内部，这些 bean 定义表示为 `BeanDefinition` 对象，其中包含（除其他信息外）以下元数据：

* 全限定类名：通常是正在定义的 bean 的实际实现类。
* Bean 行为配置元素，说明 bean 在容器中的行为方式（作用域、生命周期回调等）。
* 对 bean 完成其工作所需的其他 bean 的引用。这些引用也称为协作者或依赖项。
* 在新创建的对象中设置的其他配置设置——例如，管理连接池的 bean 中使用的池的大小限制或连接数。

此元数据转换为构成每个 bean 定义的一组属性。下表描述了这些属性：

[[beans-factory-bean-definition-tbl]]
.Bean 定义
|===
| 属性| 解释在...

| Class
| xref:core/beans/definition.adoc#beans-factory-class[实例化 Bean]

| Name
| xref:core/beans/definition.adoc#beans-beanname[命名 Bean]

| Scope
| xref:core/beans/factory-scopes.adoc[Bean 作用域]

| Constructor arguments
| xref:core/beans/dependencies/factory-collaborators.adoc[依赖注入]

| Properties
| xref:core/beans/dependencies/factory-collaborators.adoc[依赖注入]

| Autowiring mode
| xref:core/beans/dependencies/factory-autowire.adoc[自动装配协作者]

| Lazy initialization mode
| xref:core/beans/dependencies/factory-lazy-init.adoc[延迟初始化的 Bean]

| Initialization method
| xref:core/beans/factory-nature.adoc#beans-factory-lifecycle-initializingbean[初始化回调]

| Destruction method
| xref:core/beans/factory-nature.adoc#beans-factory-lifecycle-disposablebean[销毁回调]
|===

除了包含有关如何创建特定 bean 的信息的 bean 定义外，`ApplicationContext` 实现还允许注册在容器外部（由用户）创建的现有对象。
这是通过 `getBeanFactory()` 方法访问 ApplicationContext 的 `BeanFactory` 来完成的，该方法返回 `StandardBeanFactory` 实现。
`StandardBeanFactory` 通过 `registerSingleton(..)` 和 `registerBeanDefinition(..)` 方法支持此注册。
但是，典型的应用程序仅使用通过常规 bean 定义元数据定义的 bean。

[NOTE]
====
Bean 元数据和手动提供的单例实例需要尽早注册，以便容器在自动装配和其他内省步骤中正确地推理它们。
虽然在某种程度上支持覆盖现有元数据和现有单例实例，但官方不支持在运行时注册新 bean（与对工厂的实时访问并发），这可能会导致并发访问异常、bean 容器中的状态不一致，或两者兼而有之。
====

[[beans-definition-overriding]]
== 覆盖 Bean

当使用已分配的标识符注册 bean 时，就会发生 bean 覆盖。虽然 bean 覆盖是可能的，但这会使配置更难阅读，并且此功能将在未来的版本中弃用。

要完全禁用 bean 覆盖，您可以在刷新 `ApplicationContext` 之前将 `allowBeanDefinitionOverriding` 设置为 `false`。
在此设置中，如果使用 bean 覆盖，则会抛出异常。

默认情况下，容器会在 `INFO` 级别记录每次 bean 覆盖，以便您可以相应地调整配置。
虽然不推荐，但您可以通过将 `allowBeanDefinitionOverriding` 标志设置为 `true` 来使这些日志静音。

NOTE: 我们承认在测试中覆盖 bean 很方便，并且对此有明确的支持。有关更多详细信息，请参阅 xref:testing/annotations/integration-infra/annotation-beanoverriding.adoc[本节]。

[[beans-beanname]]
== 命名 Bean

每个 bean 都有一个或多个标识符。这些标识符在托管 bean 的容器内必须是唯一的。一个 bean 通常只有一个标识符。但是，如果它需要多个，多余的可以被视为别名。

在基于 XML 的配置元数据中，您使用 `id` 属性、`name` 属性或两者来指定 bean 标识符。`id` 属性允许您指定恰好一个 `id`。
按照惯例，这些名称是字母数字（'myBean'、'someService' 等），但它们也可以包含特殊字符。
如果您想为 bean 引入其他别名，也可以在 `name` 属性中指定它们，用逗号 (`,`)、分号 (`;`) 或空格分隔。
虽然 `id` 属性定义为 `xsd:string` 类型，但 bean `id` 的唯一性由容器强制执行，而不是由 XML 解析器强制执行。

您不需要为 bean 提供 `name` 或 `id`。如果您没有显式提供 `name` 或 `id`，容器会为该 bean 生成一个唯一的名称。
但是，如果您想通过使用 `ref` 元素或 Service Locator 风格的查找按名称引用该 bean，则必须提供名称。
不提供名称的动机与使用 xref:core/beans/dependencies/factory-properties-detailed.adoc#beans-inner-beans[内部 bean]
和 xref:core/beans/dependencies/factory-autowire.adoc[自动装配协作者] 有关。

.Bean 命名约定
****
惯例是在命名 bean 时使用标准 Java 实例字段名称约定。
也就是说，bean 名称以小写字母开头，并从那里开始驼峰式大小写。
此类名称的示例包括 `accountManager`、`accountService`、`userDao`、`loginController` 等。

一致地命名 bean 使您的配置更易于阅读和理解。
此外，如果您使用 Infra AOP，当将建议应用于按名称相关的一组 bean 时，这会有很大帮助。
****

NOTE: 通过类路径中的组件扫描，Infra 会按照前面描述的规则为未命名的组件生成 bean 名称：本质上，采用简单的类名并将其首字符转换为小写。
但是，在（不常见的）特殊情况下，如果有多个字符且第一个和第二个字符都是大写字母，则保留原始大小写。
这些规则与 `java.beans.Introspector.decapitalize`（Infra 在此处使用）定义的规则相同。

[[beans-beanname-alias]]
=== 在 Bean 定义之外为 Bean 设置别名

在 bean 定义本身中，您可以通过使用 `id` 属性指定的一个名称与 `name` 属性中的任意数量的其他名称的组合，为 bean 提供多个名称。
这些名称可以是同一 bean 的等效别名，并且在某些情况下很有用，例如让应用程序中的每个组件通过使用特定于该组件本身的 bean 名称来引用公共依赖项。

然而，在实际定义 bean 的地方指定所有别名并不总是足够的。有时需要为在别处定义的 bean 引入别名。
这通常发生在大型系统中，其中配置在每个子系统之间拆分，每个子系统都有自己的一组对象定义。
在基于 XML 的配置元数据中，您可以使用 `<alias/>` 元素来实现此目的。以下示例显示了如何执行此操作：

[source,xml,indent=0,subs="verbatim,quotes"]
----
<alias name="fromName" alias="toName"/>
----

在这种情况下，名为 `fromName` 的 bean（在同一容器中）在使用此别名定义后，也可以被称为 `toName`。

例如，子系统 A 的配置元数据可以通过 `subsystemA-dataSource` 的名称引用 DataSource。
子系统 B 的配置元数据可以通过 `subsystemB-dataSource` 的名称引用 DataSource。
当组合使用这两个子系统的主应用程序时，主应用程序通过 `myApp-dataSource` 的名称引用 DataSource。
要让所有三个名称都引用同一个对象，您可以将以下别名定义添加到配置元数据中：

[source,xml,indent=0,subs="verbatim,quotes"]
----
<alias name="myApp-dataSource" alias="subsystemA-dataSource"/>
<alias name="myApp-dataSource" alias="subsystemB-dataSource"/>
----

现在，每个组件和主应用程序都可以通过一个唯一的名称引用 dataSource，该名称保证不与任何其他定义冲突（有效地创建一个命名空间），但它们引用的是同一个 bean。

.Java 配置
****
如果您使用 Java 配置，可以使用 `@Bean` 注解来提供别名。
有关详细信息，请参阅 xref:core/beans/java/bean-annotation.adoc[使用 `@Bean` 注解]。
****

[[beans-factory-class]]
== 实例化 Bean

Bean 定义本质上是创建一或多个对象的配方。
容器在被询问时查看命名 bean 的配方，并使用该 bean 定义封装的配置元数据来创建（或获取）实际对象。

如果您使用基于 XML 的配置元数据，则在 `<bean/>` 元素的 `class` 属性中指定要实例化的对象的类型（或类）。
这个 `class` 属性（在内部是 `BeanDefinition` 实例上的 `Class` 属性）通常是强制性的。（对于例外情况，请参阅
xref:core/beans/definition.adoc#beans-factory-class-instance-factory-method[使用实例工厂方法实例化] 和 xref:core/beans/child-bean-definitions.adoc[Bean 定义继承]。）
您可以通过以下两种方式之一使用 `Class` 属性：

* 通常，在容器本身通过反射调用其构造函数直接创建 bean 的情况下，指定要构造的 bean 类，这在某种程度上等同于使用 `new` 运算符的 Java 代码。
* 在不太常见的情况下，容器调用类上的 `static` 工厂方法来创建 bean，指定包含被调用的 `static` 工厂方法的实际类。
  从 `static` 工厂方法的调用返回的对象类型可以是同一个类，也可以是完全不同的另一个类。

.嵌套类名
****
如果要为嵌套类配置 bean 定义，可以使用嵌套类的二进制名称或源名称。

例如，如果在 `com.example` 包中有一个名为 `SomeThing` 的类，并且这个 `SomeThing` 类有一个名为 `OtherThing` 的 `static` 嵌套类，
它们可以用美元符号 (`$`) 或点 (`.`) 分隔。
因此，bean 定义中 `class` 属性的值将是 `com.example.SomeThing$OtherThing` 或 `com.example.SomeThing.OtherThing`。
****

[[beans-factory-class-ctor]]
=== 使用构造函数实例化

当您通过构造函数方法创建 bean 时，所有普通类都可以被 Infra 使用并与之兼容。
也就是说，正在开发的类不需要实现任何特定接口或以特定方式编码。只需指定 bean 类就足够了。
但是，根据您为该特定 bean 使用的 IoC 类型，您可能需要一个默认（空）构造函数。

Infra IoC 容器几乎可以管理您希望它管理的任何类。它不仅限于管理真正的 JavaBeans。
大多数 Infra 用户更喜欢只有默认（无参数）构造函数和根据容器中的属性建模的适当 setter 和 getter 的实际 JavaBeans。
您也可以在容器中拥有更多异国情调的非 bean 风格的类。
例如，如果您需要使用绝对不符合 JavaBean 规范的遗留连接池，Infra 也可以管理它。

使用基于 XML 的配置元数据，您可以按如下方式指定 bean 类：

[source,xml,indent=0,subs="verbatim,quotes"]
----
<bean id="exampleBean" class="examples.ExampleBean"/>

<bean name="anotherExample" class="examples.ExampleBeanTwo"/>
----

有关向构造函数提供参数（如果需要）以及在构造对象后设置对象实例属性的机制的详细信息，请参阅
xref:core/beans/dependencies/factory-collaborators.adoc[注入依赖项]。

[[beans-factory-class-static-factory-method]]
=== 使用静态工厂方法实例化

定义使用静态工厂方法创建的 bean 时，使用 `class` 属性指定包含 `static` 工厂方法的类，并使用名为 `factory-method` 的属性指定工厂方法本身的名称。
您应该能够调用此方法（带有可选参数，如下所述）并返回一个活动对象，该对象随后被视为已通过构造函数创建。
这种 bean 定义的一个用途是在遗留代码中调用 `static` 工厂。

以下 bean 定义指定将通过调用工厂方法来创建 bean。该定义不指定返回对象的类型（类），而是指定包含工厂方法的类。
在此示例中，`createInstance()` 方法必须是 `static` 方法。以下示例显示了如何指定工厂方法：

[source,xml,indent=0,subs="verbatim,quotes"]
----
<bean id="clientService" class="examples.ClientService"
  factory-method="createInstance"/>
----

以下示例显示了一个适用于上述 bean 定义的类：

[tabs]
======
Java::
+
[source,java,indent=0,subs="verbatim,quotes",role="primary"]
----
public class ClientService {
  private static ClientService clientService = new ClientService();
  private ClientService() {}

  public static ClientService createInstance() {
    return clientService;
  }
}
----

======

有关向工厂方法提供（可选）参数以及在从工厂返回对象后设置对象实例属性的机制的详细信息，
请参阅 xref:core/beans/dependencies/factory-properties-detailed.adoc[依赖项和配置详解]。

[[beans-factory-class-instance-factory-method]]
=== 使用实例工厂方法实例化

类似于通过 xref:core/beans/definition.adoc#beans-factory-class-static-factory-method[静态工厂方法] 实例化，
使用实例工厂方法实例化会调用容器中现有 bean 的非静态方法来创建新 bean。
要使用此机制，请将 `class` 属性留空，并在 `factory-bean` 属性中指定当前（或父或祖先）容器中包含要调用以创建对象的实例方法的 bean 的名称。
使用 `factory-method` 属性设置工厂方法本身的名称。以下示例显示了如何配置此类 bean：

[source,xml,indent=0,subs="verbatim,quotes"]
----
<!-- 工厂 bean，包含名为 createClientServiceInstance() 的方法 -->
<bean id="serviceLocator" class="examples.DefaultServiceLocator">
  <!-- 注入此定位器 bean 所需的任何依赖项 -->
</bean>

<!-- 通过工厂 bean 创建的 bean -->
<bean id="clientService" factory-bean="serviceLocator"
  factory-method="createClientServiceInstance"/>
----

以下示例显示了相应的类：

[tabs]
======
Java::
+
[source,java,indent=0,subs="verbatim,quotes",role="primary"]
----
public class DefaultServiceLocator {

  private static ClientService clientService = new ClientServiceImpl();

  public ClientService createClientServiceInstance() {
    return clientService;
  }
}
----

======

一个工厂类也可以拥有多个工厂方法，如下例所示：

[source,xml,indent=0,subs="verbatim,quotes"]
----
<bean id="serviceLocator" class="examples.DefaultServiceLocator">
  <!-- 注入此定位器 bean 所需的任何依赖项 -->
</bean>

<bean id="clientService"
  factory-bean="serviceLocator"
  factory-method="createClientServiceInstance"/>

<bean id="accountService"
  factory-bean="serviceLocator"
  factory-method="createAccountServiceInstance"/>
----

以下示例显示了相应的类：

[tabs]
======
Java::
+
[source,java,indent=0,subs="verbatim,quotes",role="primary"]
----
public class DefaultServiceLocator {

  private static ClientService clientService = new ClientServiceImpl();

  private static AccountService accountService = new AccountServiceImpl();

  public ClientService createClientServiceInstance() {
    return clientService;
  }

  public AccountService createAccountServiceInstance() {
    return accountService;
  }
}
----

======

这种方法表明，工厂 bean 本身可以通过依赖注入 (DI) 进行管理和配置。
请参阅 xref:core/beans/dependencies/factory-properties-detailed.adoc[依赖项和配置详解]。

NOTE: 在 Infra 文档中，“工厂 bean”是指在 Infra 容器中配置并通过
xref:core/beans/definition.adoc#beans-factory-class-instance-factory-method[实例] 或
xref:core/beans/definition.adoc#beans-factory-class-static-factory-method[静态] 工厂方法创建对象的 bean。
相比之下，`FactoryBean`（注意大写）是指特定于 Infra 的
xref:core/beans/factory-extension.adoc#beans-factory-extension-factorybean[`FactoryBean`] 实现类。

[[beans-factory-type-determination]]
=== 确定 Bean 的运行时类型

确定特定 bean 的运行时类型并非易事。
bean 元数据定义中指定的类只是一个初始类引用，可能与声明的工厂方法结合使用，或者是一个 `FactoryBean` 类，这可能会导致 bean 的运行时类型不同，或者在实例级工厂方法的情况下根本没有设置（而是通过指定的 `factory-bean` 名称解析）。
此外，AOP 代理可能会用基于接口的代理包装 bean 实例，从而限制目标 bean 实际类型的暴露（仅限于其实现的接口）。

找出特定 bean 的实际运行时类型的推荐方法是对指定的 bean 名称调用 `BeanFactory.getType`。
这考虑了上述所有情况，并返回 `BeanFactory.getBean` 调用将针对相同 bean 名称返回的对象类型。
