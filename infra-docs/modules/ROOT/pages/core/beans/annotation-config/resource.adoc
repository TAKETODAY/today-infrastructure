[[beans-resource-annotation]]
= 使用 `@Resource` 注入

Infra 还支持在字段或 bean 属性 setter 方法上使用 JSR-250 `@Resource` 注解 (`jakarta.annotation.Resource`) 进行注入。
这是 Jakarta EE 中的常见模式：例如，在 JSF 管理的 bean 和 JAX-WS 端点中。
Infra 也支持 Infra 管理对象的这种模式。

`@Resource` 接受一个 name 属性。默认情况下，Infra 将该值解释为要注入的 bean 名称。
换句话说，它遵循按名称语义，如下例所示：

--
[tabs]
======
Java::
+
[source,java,indent=0,subs="verbatim,quotes",role="primary"]
----
public class SimpleMovieLister {

  private MovieFinder movieFinder;

  @Resource(name="myMovieFinder") // <1>
  public void setMovieFinder(MovieFinder movieFinder) {
    this.movieFinder = movieFinder;
  }
}
----
<1> 这行注入了一个 `@Resource`。

======
--

如果没有显式指定名称，则默认名称派生自字段名称或 setter 方法。
如果是字段，则采用字段名称。如果是 setter 方法，则采用 bean 属性名称。
以下示例将会把名为 `movieFinder` 的 bean 注入到其 setter 方法中：

--
[tabs]
======
Java::
+
[source,java,indent=0,subs="verbatim,quotes",role="primary"]
----
public class SimpleMovieLister {

  private MovieFinder movieFinder;

  @Resource
  public void setMovieFinder(MovieFinder movieFinder) {
    this.movieFinder = movieFinder;
  }
}
----

======
--

NOTE: 注解提供的名称由 `CommonAnnotationBeanPostProcessor` 知道的 `ApplicationContext` 解析为 bean 名称。
如果您显式配置 Infra {today-framework-api}/jndi/support/SimpleJndiBeanFactory.html[`SimpleJndiBeanFactory`]，可以通过 JNDI 解析名称。
但是，我们建议您依赖默认行为并使用 Infra JNDI 查找功能来保持间接级别。

在未指定显式名称的 `@Resource` 使用的独占情况下，类似于 `@Autowired`，`@Resource` 查找主类型匹配而不是特定的命名 bean，
并解析众所周知的可解析依赖项：`BeanFactory`、`ApplicationContext`、`ResourceLoader`、`ApplicationEventPublisher` 和 `MessageSource` 接口。

因此，在以下示例中，`customerPreferenceDao` 字段首先查找名为 "customerPreferenceDao" 的 bean，然后回退到 `CustomerPreferenceDao` 类型的主类型匹配：

--
[tabs]
======
Java::
+
[source,java,indent=0,subs="verbatim,quotes",role="primary"]
----
public class MovieRecommender {

  @Resource
  private CustomerPreferenceDao customerPreferenceDao;

  @Resource
  private ApplicationContext context; // <1>

  public MovieRecommender() {
  }

  // ...
}
----
<1> `context` 字段是根据已知的可解析依赖项类型注入的：`ApplicationContext`。

======
--
