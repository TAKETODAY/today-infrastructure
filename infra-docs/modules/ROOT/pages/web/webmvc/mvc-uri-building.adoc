[[mvc-uri-building]]
= URI 链接

本节描述了 TODAY Framework 中用于处理 URI 的各种选项。

include::partial$web/web-uris.adoc[leveloffset=+1]



[[mvc-uricomponentsbuilder]]
== 相对 Web 请求

您可以使用 `UriComponentsBuilder` 创建相对于当前请求的 URI，如下例所示：

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
----
HttpServletRequest request = ...

// 重用 scheme, host, port, path, 和 query string...

URI uri = UriComponentsBuilder.fromRequest(request)
    .replaceQueryParam("accountId", "{id}")
    .build("123");
----

您可以创建相对于上下文路径（context path）的 URI，如下例所示：

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
----
HttpServletRequest request = ...

// 重用 scheme, host, port, 和 context path...

URI uri = UriComponentsBuilder.fromContextPath(request)
    .path("/accounts")
    .build()
    .toUri();
----


您可以创建相对于 Servlet 的 URI（例如 `/main/{asterisk}`），如下例所示：

[tabs]
======
Java::
+
[source,java,indent=0,subs="verbatim,quotes",role="primary"]
----
	HttpServletRequest request = ...

	// 重用 scheme, host, port, context path, 和 Servlet mapping prefix...

	URI uri = UriComponentsBuilder.fromServletMapping(request)
			.path("/accounts")
			.build()
			.toUri();
----
======



[[mvc-links-to-controllers]]
== 指向控制器的链接

Web MVC 提供了一种机制来准备指向控制器方法的链接。例如，下面的 MVC 控制器允许创建链接：

[tabs]
======
Java::
+
[source,java,indent=0,subs="verbatim,quotes",role="primary"]
----
@Controller
@RequestMapping("/hotels/{hotel}")
public class BookingController {

  @GetMapping("/bookings/{booking}")
  public ModelAndView getBooking(@PathVariable Long booking) {
    // ...
  }
}
----

======

您可以通过名称引用方法来准备链接，如下例所示：

[tabs]
======
Java::
+
[source,java,indent=0,subs="verbatim,quotes",role="primary"]
----
UriComponents uriComponents = MvcUriComponentsBuilder
  .fromMethodName(BookingController.class, "getBooking", 21).buildAndExpand(42);

URI uri = uriComponents.encode().toUri();
----
======

在前面的示例中，我们提供了实际的方法参数值（在本例中为 long 值：`21`）作为路径变量并插入到 URL 中。
此外，我们提供了值 `42` 来填充任何剩余的 URI 变量，例如从类型级请求映射继承的 `hotel` 变量。
如果方法有更多参数，我们可以为不需要用于 URL 的参数提供 null。通常，只有 `@PathVariable` 和 `@RequestParam` 参数与构建 URL 相关。

还有其他使用 `MvcUriComponentsBuilder` 的方法。例如，您可以使用类似于通过代理进行 mock 测试的技术，
以避免通过名称引用控制器方法，如下例所示（该示例假设静态导入了 `MvcUriComponentsBuilder.on`）：

[tabs]
======
Java::
+
[source,java,indent=0,subs="verbatim,quotes",role="primary"]
----
UriComponents uriComponents = MvcUriComponentsBuilder
  .fromMethodCall(on(BookingController.class).getBooking(21)).buildAndExpand(42);

URI uri = uriComponents.encode().toUri();
----
======

NOTE: 控制器方法签名在设计用于通过 `fromMethodCall` 创建链接时受到限制。除了需要适当的参数签名外，
返回类型还有一个技术限制（即为链接构建器调用生成运行时代理），因此返回类型不能是 `final`。
特别是，用于视图名称的常见 `String` 返回类型在这里不起作用。您应该改用 `ModelAndView` 甚至普通的 `Object`（带有 `String` 返回值）。

前面的示例使用了 `MvcUriComponentsBuilder` 中的静态方法。在内部，它们依赖 `UriComponentsBuilder`
从当前请求的 scheme、host、port、context path 和 servlet path 准备基本 URL。这在大多数情况下效果很好。
但是，有时这可能还不够。例如，您可能处于请求上下文之外（例如准备链接的批处理过程），或者您可能需要插入路径前缀
（例如从请求路径中删除并需要重新插入到链接中的区域设置前缀）。

对于这种情况，您可以使用接受 `UriComponentsBuilder` 以使用基本 URL 的静态 `fromXxx` 重载方法。
或者，您可以创建一个带有基本 URL 的 `MvcUriComponentsBuilder` 实例，然后使用基于实例的 `withXxx` 方法。
例如，下面的清单使用了 `withMethodCall`：

[tabs]
======
Java::
+
[source,java,indent=0,subs="verbatim,quotes",role="primary"]
----
	UriComponentsBuilder base = UriComponentsBuilder.forHttpRequest(req).path("/en");
	MvcUriComponentsBuilder builder = MvcUriComponentsBuilder.relativeTo(base);
	builder.withMethodCall(on(BookingController.class).getBooking(21)).buildAndExpand(42);

	URI uri = uriComponents.encode().toUri();
----

======



[[mvc-links-to-controllers-from-views]]
== 视图中的链接

在 Thymeleaf、FreeMarker 或 JSP 等视图中，您可以通过引用每个请求映射的隐式或显式分配的名称，
来构建指向带注解控制器的链接。

考虑以下示例：

[tabs]
======
Java::
+
[source,java,indent=0,subs="verbatim,quotes",role="primary"]
----
@RequestMapping("/people/{id}/addresses")
public class PersonAddressController {

  @RequestMapping("/{country}")
  public HttpEntity<PersonAddress> getAddress(@PathVariable String country) { ... }
}
----
======
