[[mvc-container-config]]
= Servlet 配置

在 Servlet 环境中，您可以选择以编程方式配置 Servlet 容器，作为 `web.xml` 文件的替代方案或与其结合使用。
以下示例注册了一个 `MockDispatcher`：

[tabs]
======
Java::
+
[source,java,indent=0,subs="verbatim,quotes",role="primary"]
----
import infra.web.WebApplicationInitializer;

public class MyWebApplicationInitializer implements WebApplicationInitializer {

  @Override
  public void onStartup(ServletContext container) {
    XmlWebApplicationContext appContext = new XmlWebApplicationContext();
    appContext.setConfigLocation("/WEB-INF/spring/dispatcher-config.xml");

    ServletRegistration.Dynamic registration = container.addServlet("dispatcher", new DispatcherServlet(appContext));
    registration.setLoadOnStartup(1);
    registration.addMapping("/");
  }
}
----

======


`WebApplicationInitializer` 是 Web MVC 提供的一个接口，它确保您的实现被检测到并自动用于初始化任何 Servlet 3 容器。
名为 `AbstractDispatcherServletInitializer` 的 `WebApplicationInitializer` 抽象基类实现使得注册
`MockDispatcher` 变得更加容易，只需重写方法来指定 servlet 映射和 `MockDispatcher` 配置的位置。

对于使用基于 Java 的 Infra 配置的应用程序，建议这样做，如下例所示：

[tabs]
======
Java::
+
[source,java,indent=0,subs="verbatim,quotes",role="primary"]
----
public class MyWebAppInitializer extends AbstractAnnotationConfigDispatcherServletInitializer {

  @Override
  protected Class<?>[] getRootConfigClasses() {
    return null;
  }

  @Override
  protected Class<?>[] getServletConfigClasses() {
    return new Class<?>[] { MyWebConfig.class };
  }

  @Override
  protected String[] getServletMappings() {
    return new String[] { "/" };
  }
}
----
======

如果您使用基于 XML 的 Infra 配置，您应该直接扩展 `AbstractDispatcherServletInitializer`，如下例所示：

[tabs]
======
Java::
+
[source,java,indent=0,subs="verbatim,quotes",role="primary"]
----
public class MyWebAppInitializer extends AbstractDispatcherServletInitializer {

  @Override
  protected WebApplicationContext createRootApplicationContext() {
    return null;
  }

  @Override
  protected WebApplicationContext createServletApplicationContext() {
    XmlWebApplicationContext cxt = new XmlWebApplicationContext();
    cxt.setConfigLocation("/WEB-INF/spring/dispatcher-config.xml");
    return cxt;
  }

  @Override
  protected String[] getServletMappings() {
    return new String[] { "/" };
  }
}
----

======

`AbstractDispatcherServletInitializer` 还提供了一种方便的方法来添加 `Filter` 实例，
并使它们自动映射到 `MockDispatcher`，如下例所示：

[tabs]
======
Java::
+
[source,java,indent=0,subs="verbatim,quotes",role="primary"]
----
public class MyWebAppInitializer extends AbstractDispatcherServletInitializer {

  // ...

  @Override
  protected Filter[] getServletFilters() {
    return new Filter[] {
      new HiddenHttpMethodFilter(), new CharacterEncodingFilter() };
  }
}
----
======

每个过滤器都根据其具体类型添加了一个默认名称，并自动映射到 `MockDispatcher`。

`AbstractDispatcherServletInitializer` 的 `isAsyncSupported` 受保护方法提供了一个单一的地方来在
`MockDispatcher` 和映射到它的所有过滤器上启用异步支持。默认情况下，此标志设置为 `true`。

最后，如果您需要进一步自定义 `MockDispatcher` 本身，您可以重写 `createDispatcherServlet` 方法。
