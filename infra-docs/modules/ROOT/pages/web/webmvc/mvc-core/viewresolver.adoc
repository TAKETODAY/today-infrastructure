[[mvc-viewresolver]]
= 视图解析

Web MVC 定义了 `ViewResolver` 和 `View` 接口，让您可以在浏览器中渲染模型，而无需将您绑定到特定的视图技术。
`ViewResolver` 提供了视图名称和实际视图之间的映射。`View` 解决了在移交给特定视图技术之前的数据准备问题。

下表提供了有关 `ViewResolver` 层次结构的更多详细信息：

[[mvc-view-resolvers-tbl]]
.ViewResolver 实现
|===
| ViewResolver| 描述

| `AbstractCachingViewResolver`
| `AbstractCachingViewResolver` 的子类缓存它们解析的视图实例。
  缓存提高了某些视图技术的性能。您可以通过将 `cache` 属性设置为 `false` 来关闭缓存。
  此外，如果您必须在运行时刷新某个视图（例如，当 FreeMarker 模板被修改时），
  您可以使用 `removeFromCache(String viewName, Locale loc)` 方法。

| `UrlBasedViewResolver`
| `ViewResolver` 接口的简单实现，它实现了逻辑视图名称到 URL 的直接解析，而无需显式的映射定义。
  如果您的逻辑名称以直接的方式与视图资源的名称匹配，而不需要任意映射，这是合适的。

| `InternalResourceViewResolver`
| `UrlBasedViewResolver` 的便捷子类，支持 `InternalResourceView`（实际上是 Servlets 和 JSP）
  以及诸如 `JstlView` 之类的子类。您可以使用 `setViewClass(..)` 为此解析器生成的所有视图指定视图类。
  有关详细信息，请参阅 {today-framework-api}/web/reactive/result/view/UrlBasedViewResolver.html[`UrlBasedViewResolver`] javadoc。

| `FreeMarkerViewResolver`
| `UrlBasedViewResolver` 的便捷子类，支持 `FreeMarkerView` 及其自定义子类。

| `ContentNegotiatingViewResolver`
| `ViewResolver` 接口的实现，根据请求文件名或 `Accept` 头解析视图。
  参见 xref:web/webmvc/mvc-core/viewresolver.adoc#mvc-multiple-representations[内容协商]。

| `BeanNameViewResolver`
| `ViewResolver` 接口的实现，将视图名称解释为当前应用程序上下文中的 bean 名称。
  这是一个非常灵活的变体，允许根据不同的视图名称混合和匹配不同的视图类型。
  每个这样的 `View` 都可以定义为 bean，例如在 XML 或配置类中。
|===


[[mvc-viewresolver-handling]]
== 处理

您可以通过声明多个解析器 bean 来链接视图解析器，并在必要时通过设置 `order` 属性来指定排序。
请记住，order 属性越高，视图解析器在链中的位置越靠后。

`ViewResolver` 的契约指定它可以返回 null 以指示找不到视图。
但是，对于 JSP 和 `InternalResourceViewResolver`，判断 JSP 是否存在的唯一方法是通过
`RequestDispatcher` 执行分派。因此，您必须始终将 `InternalResourceViewResolver` 配置为视图解析器整体顺序中的最后一个。

配置视图解析就像将 `ViewResolver` bean 添加到 Infra 配置一样简单。
xref:web/webmvc/mvc-config.adoc[MVC 配置] 为 xref:web/webmvc/mvc-config/view-resolvers.adoc[视图解析器]
提供了专用的配置 API，并用于添加无逻辑的 xref:web/webmvc/mvc-config/view-controller.adoc[视图控制器]，
这对于没有控制器逻辑的 HTML 模板渲染很有用。


[[mvc-redirecting-redirect-prefix]]
== 重定向

视图名称中的特殊 `redirect:` 前缀允许您执行重定向。`UrlBasedViewResolver`（及其子类）
将其识别为需要重定向的指令。视图名称的其余部分是重定向 URL。

净效果与控制器返回 `RedirectView` 相同，但现在控制器本身可以按照逻辑视图名称进行操作。
逻辑视图名称（如 `redirect:/myapp/some/resource`）相对于当前 Servlet 上下文进行重定向，
而名称如 `redirect:https://myhost.com/some/arbitrary/path` 则重定向到绝对 URL。


[[mvc-redirecting-forward-prefix]]
== 转发

您还可以对视图名称使用特殊的 `forward:` 前缀，这些名称最终由 `UrlBasedViewResolver` 及其子类解析。
这将创建一个 `InternalResourceView`，它执行 `RequestDispatcher.forward()`。
因此，此前缀对 `InternalResourceViewResolver` 和 `InternalResourceView`（用于 JSP）没有用，
但如果您使用其他视图技术但仍想强制将资源转发给 Servlet/JSP 引擎处理，它可能会有所帮助。
请注意，您也可以链接多个视图解析器。


[[mvc-multiple-representations]]
== 内容协商

{today-framework-api}/web/mockApi/view/ContentNegotiatingViewResolver.html[`ContentNegotiatingViewResolver`]
本身不解析视图，而是委托给其他视图解析器，并选择类似于客户端请求的表示形式的视图。
表示形式可以根据 `Accept` 头或查询参数（例如 `"/path?format=pdf"`）确定。

`ContentNegotiatingViewResolver` 通过将请求媒体类型与每个 `ViewResolvers` 关联的 `View`
支持的媒体类型（也称为 `Content-Type`）进行比较，来选择适当的 `View` 来处理请求。
列表中具有兼容 `Content-Type` 的第一个 `View` 将表示形式返回给客户端。
如果 `ViewResolver` 链无法提供兼容的视图，则会查阅通过 `DefaultViews` 属性指定的视图列表。
后一种选项适用于单例 `Views`，无论逻辑视图名称如何，它们都可以渲染当前资源的适当表示形式。
`Accept` 头可以包含通配符（例如 `text/{asterisk}`），在这种情况下，`Content-Type` 为 `text/xml` 的 `View` 是兼容的匹配项。

有关配置详细信息，请参阅 xref:web/webmvc/mvc-config.adoc[MVC 配置] 下的 xref:web/webmvc/mvc-config/view-resolvers.adoc[视图解析器]。
