/*
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER.
 *
 * Copyright (c) 2018 Oracle and/or its affiliates. All rights reserved.
 *
 * The contents of this file are subject to the terms of either the GNU
 * General Public License Version 2 only ("GPL") or the Common Development
 * and Distribution License("CDDL") (collectively, the "License").  You
 * may not use this file except in compliance with the License.  You can
 * obtain a copy of the License at
 * https://oss.oracle.com/licenses/CDDL+GPL-1.1
 * or LICENSE.txt.  See the License for the specific
 * language governing permissions and limitations under the License.
 *
 * When distributing the software, include this License Header Notice in each
 * file and include the License file at LICENSE.txt.
 *
 * GPL Classpath Exception:
 * Oracle designates this particular file as subject to the "Classpath"
 * exception as provided by Oracle in the GPL Version 2 section of the License
 * file that accompanied this code.
 *
 * Modifications:
 * If applicable, add the following below the License Header, with the fields
 * enclosed by brackets [] replaced by your own identifying information:
 * "Portions Copyright [year] [name of copyright owner]"
 *
 * Contributor(s):
 * If you wish your version of this file to be governed by only the CDDL or
 * only the GPL Version 2, indicate your decision by adding "[Contributor]
 * elects to include this software in this distribution under the [CDDL or GPL
 * Version 2] license."  If you don't indicate a single choice of license, a
 * recipient has the option to distribute your version of this file under
 * either the CDDL, the GPL Version 2 or to extend the choice of license to
 * its licensees as provided above.  However, if you add GPL Version 2 code
 * and therefore, elected the GPL Version 2 license, then the option applies
 * only if the new code is made subject to such option by the copyright
 * holder.
 */

/* Generated By:JJTree&JavaCC: Do not edit this line. ELParserTokenManager.java */
package cn.taketoday.expression.parser;

import java.io.IOException;
import java.util.Stack;

import cn.taketoday.lang.Constant;

/**
 * @author TODAY <br>
 * 2019-02-23 14:26
 */
public class ExpressionParserTokenManager implements ELParserConstants {

  private final Stack<Integer> stack = new Stack<>();

  /** Token literal values. */
  public static final String[] jjstrLiteralImages = { //
          "", null, "\44\173", "\43\173", null, null, null, null, null, //
          "\173", "\175", null, null, null, null, null, "\164\162\165\145", //
          "\146\141\154\163\145", "\156\165\154\154", "\56", "\50", "\51", "\133", //
          "\135", "\72", "\54", "\73", "\76", "\147\164", "\74", "\154\164", "\76\75", //
          "\147\145", "\74\75", "\154\145", "\75\75", "\145\161", "\41\75", "\156\145", //
          "\41", "\156\157\164", "\46\46", "\141\156\144", "\174\174", "\157\162", //
          "\145\155\160\164\171", "\151\156\163\164\141\156\143\145\157\146", "\52", //
          "\53", "\55", "\77", "\57", "\144\151\166", "\45", "\155\157\144", "\53\75", //
          "\75", "\55\76", null, null, null, null, null,//
  };

  /** Lexer state names. */
  public static final String[] lexStateNames = { "DEFAULT", "IN_EXPRESSION", "IN_MAP", };

  /** Lex State array. */
  public static final int[] jjnewLexState = { //
          -1, -1, 1, 1, -1, -1, -1, -1, -1, 2, -1, -1, -1, -1, //
          -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, //
          -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, //
          -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, //
          -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
  };

  static final long[] jjtoToken = { 0x47ffffffffffde0fL };
  static final long[] jjtoSkip = { 0x1f0L };

  private final int[] jjrounds = new int[35];
  private final int[] jjstateSet = new int[70];
  private final StringBuilder image = new StringBuilder();

  protected volatile char curChar;

  protected final SimpleCharStream input_stream;

  public ExpressionParserTokenManager(SimpleCharStream stream) {
    this.input_stream = stream;
  }

  public ExpressionParserTokenManager(SimpleCharStream stream, int lexState) {
    this(stream);
    SwitchTo(lexState);
  }

  private final int jjStopStringLiteralDfa_0(int pos, long active0) {

    if (pos == 0) {
      if ((active0 & 0x10L) != 0L)
        return 2;
      if ((active0 & 0xcL) != 0L) {
        jjmatchedKind = 1;
        return 4;
      }
      return -1;
    }
    return -1;
  }

  private final int jjStartNfa_0(int pos, long active0) {
    return jjMoveNfa_0(jjStopStringLiteralDfa_0(pos, active0), pos + 1);
  }

  private int jjStopAtPos(int pos, int kind) {
    jjmatchedKind = kind;
    jjmatchedPos = pos;
    return pos + 1;
  }

  private int jjMoveStringLiteralDfa0_0() {
    return switch (curChar) {
      case 35 -> jjMoveStringLiteralDfa1_0(0x8L);
      case 36 -> jjMoveStringLiteralDfa1_0(0x4L);
      case 92 -> jjStartNfaWithStates_0(0, 4, 2);
      default -> jjMoveNfa_0(6, 0);
    };
  }

  private int jjMoveStringLiteralDfa1_0(long active0) {
    try {
      curChar = input_stream.readChar();
    }
    catch (IOException e) {
      jjStopStringLiteralDfa_0(0, active0);
      return 1;
    }
    if (curChar == 123) {
      if ((active0 & 0x4L) != 0L)
        return jjStopAtPos(1, 2);
      else if ((active0 & 0x8L) != 0L)
        return jjStopAtPos(1, 3);
    }
    return jjStartNfa_0(0, active0);
  }

  private int jjStartNfaWithStates_0(int pos, int kind, int state) {
    jjmatchedKind = kind;
    jjmatchedPos = pos;
    try {
      curChar = input_stream.readChar();
    }
    catch (IOException e) {
      return pos + 1;
    }
    return jjMoveNfa_0(state, pos + 1);
  }

  static final long[] jjbitVec0 = { 0xfffffffffffffffeL, 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffffffffffffL };
  static final long[] jjbitVec2 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };

  private int jjMoveNfa_0(int startState, int curPos) {
    int startsAt = 0;
    jjnewStateCnt = 7;
    int i = 1;
    jjstateSet[0] = startState;
    int kind = 0x7fffffff;
    for (; ; ) {
      if (++jjround == 0x7fffffff)
        ReInitRounds();
      if (curChar < 64) {
        long l = 1L << curChar;
        do {
          switch (jjstateSet[--i]) {
            case 6:
              if ((0xffffffe7ffffffffL & l) != 0L) {
                if (kind > 1)
                  kind = 1;
                jjCheckNAddStates(0, 3);
              }
              else if ((0x1800000000L & l) != 0L) {
                if (kind > 1)
                  kind = 1;
              }
              if (curChar == 35)
                jjCheckNAdd(4);
              else if (curChar == 36)
                jjCheckNAdd(4);
              break;
            case 0:
            case 4:
              if ((0xffffffe7ffffffffL & l) == 0L)
                break;
              if (kind > 1)
                kind = 1;
              jjCheckNAddStates(0, 3);
              break;
            case 2:
              if ((0x1800000000L & l) == 0L)
                break;
              if (kind > 1)
                kind = 1;
              jjCheckNAddStates(0, 3);
              break;
            case 3:
              if (curChar == 36)
                jjCheckNAdd(4);
              break;
            case 5:
              if (curChar == 35)
                jjCheckNAdd(4);
              break;
            default:
              break;
          }
        }
        while (i != startsAt);
      }
      else if (curChar < 128) {
        long l = 1L << (curChar & 077);
        do {
          switch (jjstateSet[--i]) {
            case 6:
              if ((0xffffffffefffffffL & l) != 0L) {
                if (kind > 1)
                  kind = 1;
                jjCheckNAddStates(0, 3);
              }
              else if (curChar == 92)
                jjstateSet[jjnewStateCnt++] = 2;
              break;
            case 0:
              if ((0xffffffffefffffffL & l) == 0L)
                break;
              if (kind > 1)
                kind = 1;
              jjCheckNAddStates(0, 3);
              break;
            case 1:
              if (curChar == 92)
                jjstateSet[jjnewStateCnt++] = 2;
              break;
            case 2:
              if (curChar != 92)
                break;
              if (kind > 1)
                kind = 1;
              jjCheckNAddStates(0, 3);
              break;
            case 4:
              if ((0xf7ffffffffffffffL & l) == 0L)
                break;
              if (kind > 1)
                kind = 1;
              jjCheckNAddStates(0, 3);
              break;
            default:
              break;
          }
        }
        while (i != startsAt);
      }
      else {
        int hiByte = (int) (curChar >> 8);
        int i1 = hiByte >> 6;
        long l1 = 1L << (hiByte & 077);
        int i2 = (curChar & 0xff) >> 6;
        long l2 = 1L << (curChar & 077);
        do {
          switch (jjstateSet[--i]) {
            case 6, 0, 4 -> {
              if (!jjCanMove_0(hiByte, i1, i2, l1, l2))
                break;
              if (kind > 1)
                kind = 1;
              jjCheckNAddStates(0, 3);
            }
            default -> {
            }
          }
        }
        while (i != startsAt);
      }
      if (kind != 0x7fffffff) {
        jjmatchedKind = kind;
        jjmatchedPos = curPos;
        kind = 0x7fffffff;
      }
      ++curPos;
      if ((i = jjnewStateCnt) == (startsAt = 7 - (jjnewStateCnt = startsAt)))
        return curPos;
      try {
        curChar = input_stream.readChar();
      }
      catch (IOException e) {
        return curPos;
      }
    }
  }

  private final int jjStopStringLiteralDfa_2(int pos, long active0) {
    switch (pos) {
      case 0:
        if ((active0 & 0x80000L) != 0L)
          return 1;
        if ((active0 & 0x50755550070000L) != 0L) {
          jjmatchedKind = 58;
          return 6;
        }
        return -1;
      case 1:
        if ((active0 & 0x105550000000L) != 0L)
          return 6;
        if ((active0 & 0x50650000070000L) != 0L) {
          jjmatchedKind = 58;
          jjmatchedPos = 1;
          return 6;
        }
        return -1;
      case 2:
        if ((active0 & 0x50050000000000L) != 0L)
          return 6;
        if ((active0 & 0x600000070000L) != 0L) {
          jjmatchedKind = 58;
          jjmatchedPos = 2;
          return 6;
        }
        return -1;
      case 3:
        if ((active0 & 0x50000L) != 0L)
          return 6;
        if ((active0 & 0x600000020000L) != 0L) {
          jjmatchedKind = 58;
          jjmatchedPos = 3;
          return 6;
        }
        return -1;
      case 4:
        if ((active0 & 0x400000000000L) != 0L) {
          jjmatchedKind = 58;
          jjmatchedPos = 4;
          return 6;
        }
        if ((active0 & 0x200000020000L) != 0L)
          return 6;
        return -1;
      case 5:
        if ((active0 & 0x400000000000L) != 0L) {
          jjmatchedKind = 58;
          jjmatchedPos = 5;
          return 6;
        }
        return -1;
      case 6:
        if ((active0 & 0x400000000000L) != 0L) {
          jjmatchedKind = 58;
          jjmatchedPos = 6;
          return 6;
        }
        return -1;
      case 7:
        if ((active0 & 0x400000000000L) != 0L) {
          jjmatchedKind = 58;
          jjmatchedPos = 7;
          return 6;
        }
        return -1;
      case 8:
        if ((active0 & 0x400000000000L) != 0L) {
          jjmatchedKind = 58;
          jjmatchedPos = 8;
          return 6;
        }
        return -1;
      default:
        return -1;
    }
  }

  private final int jjStartNfa_2(int pos, long active0) {
    return jjMoveNfa_2(jjStopStringLiteralDfa_2(pos, active0), pos + 1);
  }

  private int jjMoveStringLiteralDfa0_2() {
    switch (curChar) {
      case 33:
        jjmatchedKind = 39;
        return jjMoveStringLiteralDfa1_2(0x2000000000L);
      case 37:
        return jjStopAtPos(0, 53);
      case 38:
        return jjMoveStringLiteralDfa1_2(0x20000000000L);
      case 40:
        return jjStopAtPos(0, 20);
      case 41:
        return jjStopAtPos(0, 21);
      case 42:
        return jjStopAtPos(0, 47);
      case 43:
        jjmatchedKind = 48;
        return jjMoveStringLiteralDfa1_2(0x80000000000000L);
      case 44:
        return jjStopAtPos(0, 25);
      case 45:
        jjmatchedKind = 49;
        return jjMoveStringLiteralDfa1_2(0x200000000000000L);
      case 46:
        return jjStartNfaWithStates_2(0, 19, 1);
      case 47:
        return jjStopAtPos(0, 51);
      case 58:
        return jjStopAtPos(0, 24);
      case 59:
        return jjStopAtPos(0, 26);
      case 60:
        jjmatchedKind = 29;
        return jjMoveStringLiteralDfa1_2(0x200000000L);
      case 61:
        jjmatchedKind = 56;
        return jjMoveStringLiteralDfa1_2(0x800000000L);
      case 62:
        jjmatchedKind = 27;
        return jjMoveStringLiteralDfa1_2(0x80000000L);
      case 63:
        return jjStopAtPos(0, 50);
      case 91:
        return jjStopAtPos(0, 22);
      case 93:
        return jjStopAtPos(0, 23);
      case 97:
        return jjMoveStringLiteralDfa1_2(0x40000000000L);
      case 100:
        return jjMoveStringLiteralDfa1_2(0x10000000000000L);
      case 101:
        return jjMoveStringLiteralDfa1_2(0x201000000000L);
      case 102:
        return jjMoveStringLiteralDfa1_2(0x20000L);
      case 103:
        return jjMoveStringLiteralDfa1_2(0x110000000L);
      case 105:
        return jjMoveStringLiteralDfa1_2(0x400000000000L);
      case 108:
        return jjMoveStringLiteralDfa1_2(0x440000000L);
      case 109:
        return jjMoveStringLiteralDfa1_2(0x40000000000000L);
      case 110:
        return jjMoveStringLiteralDfa1_2(0x14000040000L);
      case 111:
        return jjMoveStringLiteralDfa1_2(0x100000000000L);
      case 116:
        return jjMoveStringLiteralDfa1_2(0x10000L);
      case 123:
        return jjStopAtPos(0, 9);
      case 124:
        return jjMoveStringLiteralDfa1_2(0x80000000000L);
      case 125:
        return jjStopAtPos(0, 10);
      default:
        return jjMoveNfa_2(0, 0);
    }
  }

  private int jjMoveStringLiteralDfa1_2(long active0) {
    try {
      curChar = input_stream.readChar();
    }
    catch (IOException e) {
      jjStopStringLiteralDfa_2(0, active0);
      return 1;
    }
    switch (curChar) {
      case 38:
        if ((active0 & 0x20000000000L) != 0L)
          return jjStopAtPos(1, 41);
        break;
      case 61:
        if ((active0 & 0x80000000L) != 0L)
          return jjStopAtPos(1, 31);
        else if ((active0 & 0x200000000L) != 0L)
          return jjStopAtPos(1, 33);
        else if ((active0 & 0x800000000L) != 0L)
          return jjStopAtPos(1, 35);
        else if ((active0 & 0x2000000000L) != 0L)
          return jjStopAtPos(1, 37);
        else if ((active0 & 0x80000000000000L) != 0L)
          return jjStopAtPos(1, 55);
        break;
      case 62:
        if ((active0 & 0x200000000000000L) != 0L)
          return jjStopAtPos(1, 57);
        break;
      case 97:
        return jjMoveStringLiteralDfa2_2(active0, 0x20000L);
      case 101:
        if ((active0 & 0x100000000L) != 0L)
          return jjStartNfaWithStates_2(1, 32, 6);
        else if ((active0 & 0x400000000L) != 0L)
          return jjStartNfaWithStates_2(1, 34, 6);
        else if ((active0 & 0x4000000000L) != 0L)
          return jjStartNfaWithStates_2(1, 38, 6);
        break;
      case 105:
        return jjMoveStringLiteralDfa2_2(active0, 0x10000000000000L);
      case 109:
        return jjMoveStringLiteralDfa2_2(active0, 0x200000000000L);
      case 110:
        return jjMoveStringLiteralDfa2_2(active0, 0x440000000000L);
      case 111:
        return jjMoveStringLiteralDfa2_2(active0, 0x40010000000000L);
      case 113:
        if ((active0 & 0x1000000000L) != 0L)
          return jjStartNfaWithStates_2(1, 36, 6);
        break;
      case 114:
        if ((active0 & 0x100000000000L) != 0L)
          return jjStartNfaWithStates_2(1, 44, 6);
        return jjMoveStringLiteralDfa2_2(active0, 0x10000L);
      case 116:
        if ((active0 & 0x10000000L) != 0L)
          return jjStartNfaWithStates_2(1, 28, 6);
        else if ((active0 & 0x40000000L) != 0L)
          return jjStartNfaWithStates_2(1, 30, 6);
        break;
      case 117:
        return jjMoveStringLiteralDfa2_2(active0, 0x40000L);
      case 124:
        if ((active0 & 0x80000000000L) != 0L)
          return jjStopAtPos(1, 43);
        break;
      default:
        break;
    }
    return jjStartNfa_2(0, active0);
  }

  private int jjMoveStringLiteralDfa2_2(long old0, long active0) {
    if (((active0 &= old0)) == 0L)
      return jjStartNfa_2(0, old0);
    try {
      curChar = input_stream.readChar();
    }
    catch (IOException e) {
      jjStopStringLiteralDfa_2(1, active0);
      return 2;
    }
    switch (curChar) {
      case 100:
        if ((active0 & 0x40000000000L) != 0L)
          return jjStartNfaWithStates_2(2, 42, 6);
        else if ((active0 & 0x40000000000000L) != 0L)
          return jjStartNfaWithStates_2(2, 54, 6);
        break;
      case 108:
        return jjMoveStringLiteralDfa3_2(active0, 0x60000L);
      case 112:
        return jjMoveStringLiteralDfa3_2(active0, 0x200000000000L);
      case 115:
        return jjMoveStringLiteralDfa3_2(active0, 0x400000000000L);
      case 116:
        if ((active0 & 0x10000000000L) != 0L)
          return jjStartNfaWithStates_2(2, 40, 6);
        break;
      case 117:
        return jjMoveStringLiteralDfa3_2(active0, 0x10000L);
      case 118:
        if ((active0 & 0x10000000000000L) != 0L)
          return jjStartNfaWithStates_2(2, 52, 6);
        break;
      default:
        break;
    }
    return jjStartNfa_2(1, active0);
  }

  private int jjMoveStringLiteralDfa3_2(long old0, long active0) {
    if (((active0 &= old0)) == 0L)
      return jjStartNfa_2(1, old0);
    try {
      curChar = input_stream.readChar();
    }
    catch (IOException e) {
      jjStopStringLiteralDfa_2(2, active0);
      return 3;
    }
    switch (curChar) {
      case 101:
        if ((active0 & 0x10000L) != 0L)
          return jjStartNfaWithStates_2(3, 16, 6);
        break;
      case 108:
        if ((active0 & 0x40000L) != 0L)
          return jjStartNfaWithStates_2(3, 18, 6);
        break;
      case 115:
        return jjMoveStringLiteralDfa4_2(active0, 0x20000L);
      case 116:
        return jjMoveStringLiteralDfa4_2(active0, 0x600000000000L);
      default:
        break;
    }
    return jjStartNfa_2(2, active0);
  }

  private int jjMoveStringLiteralDfa4_2(long old0, long active0) {
    if (((active0 &= old0)) == 0L)
      return jjStartNfa_2(2, old0);
    try {
      curChar = input_stream.readChar();
    }
    catch (IOException e) {
      jjStopStringLiteralDfa_2(3, active0);
      return 4;
    }
    switch (curChar) {
      case 97:
        return jjMoveStringLiteralDfa5_2(active0, 0x400000000000L);
      case 101:
        if ((active0 & 0x20000L) != 0L)
          return jjStartNfaWithStates_2(4, 17, 6);
        break;
      case 121:
        if ((active0 & 0x200000000000L) != 0L)
          return jjStartNfaWithStates_2(4, 45, 6);
        break;
      default:
        break;
    }
    return jjStartNfa_2(3, active0);
  }

  private int jjMoveStringLiteralDfa5_2(long old0, long active0) {
    if (((active0 &= old0)) == 0L)
      return jjStartNfa_2(3, old0);
    try {
      curChar = input_stream.readChar();
    }
    catch (IOException e) {
      jjStopStringLiteralDfa_2(4, active0);
      return 5;
    }
    if (curChar == 110) {
      return jjMoveStringLiteralDfa6_2(active0, 0x400000000000L);
    }
    return jjStartNfa_2(4, active0);
  }

  private int jjMoveStringLiteralDfa6_2(long old0, long active0) {
    if (((active0 &= old0)) == 0L)
      return jjStartNfa_2(4, old0);
    try {
      curChar = input_stream.readChar();
    }
    catch (IOException e) {
      jjStopStringLiteralDfa_2(5, active0);
      return 6;
    }
    if (curChar == 99) {
      return jjMoveStringLiteralDfa7_2(active0, 0x400000000000L);
    }
    return jjStartNfa_2(5, active0);
  }

  private int jjMoveStringLiteralDfa7_2(long old0, long active0) {
    if (((active0 &= old0)) == 0L)
      return jjStartNfa_2(5, old0);
    try {
      curChar = input_stream.readChar();
    }
    catch (IOException e) {
      jjStopStringLiteralDfa_2(6, active0);
      return 7;
    }
    if (curChar == 101) {
      return jjMoveStringLiteralDfa8_2(active0, 0x400000000000L);
    }
    return jjStartNfa_2(6, active0);
  }

  private int jjMoveStringLiteralDfa8_2(long old0, long active0) {
    if (((active0 &= old0)) == 0L)
      return jjStartNfa_2(6, old0);
    try {
      curChar = input_stream.readChar();
    }
    catch (IOException e) {
      jjStopStringLiteralDfa_2(7, active0);
      return 8;
    }
    if (curChar == 111) {
      return jjMoveStringLiteralDfa9_2(active0, 0x400000000000L);
    }
    return jjStartNfa_2(7, active0);
  }

  private int jjMoveStringLiteralDfa9_2(long old0, long active0) {
    if (((active0 &= old0)) == 0L)
      return jjStartNfa_2(7, old0);
    try {
      curChar = input_stream.readChar();
    }
    catch (IOException e) {
      jjStopStringLiteralDfa_2(8, active0);
      return 9;
    }
    if (curChar == 102) {
      if ((active0 & 0x400000000000L) != 0L)
        return jjStartNfaWithStates_2(9, 46, 6);
    }
    return jjStartNfa_2(8, active0);
  }

  private int jjStartNfaWithStates_2(int pos, int kind, int state) {
    jjmatchedKind = kind;
    jjmatchedPos = pos;
    try {
      curChar = input_stream.readChar();
    }
    catch (IOException e) {
      return pos + 1;
    }
    return jjMoveNfa_2(state, pos + 1);
  }

  static final long[] jjbitVec3 = { 0x1ff00000fffffffeL, 0xffffffffffffc000L, 0xffffffffL, 0x600000000000000L
  };
  static final long[] jjbitVec4 = { 0x0L, 0x0L, 0x0L, 0xff7fffffff7fffffL
  };
  static final long[] jjbitVec5 = { 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffffffffffffL
  };
  static final long[] jjbitVec6 = { 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffL, 0x0L
  };
  static final long[] jjbitVec7 = { 0xffffffffffffffffL, 0xffffffffffffffffL, 0x0L, 0x0L
  };
  static final long[] jjbitVec8 = { 0x3fffffffffffL, 0x0L, 0x0L, 0x0L
  };

  private int jjMoveNfa_2(int startState, int curPos) {
    int startsAt = 0;
    jjnewStateCnt = 35;
    int i = 1;
    jjstateSet[0] = startState;
    int kind = 0x7fffffff;
    for (; ; ) {
      if (++jjround == 0x7fffffff)
        ReInitRounds();
      if (curChar < 64) {
        long l = 1L << curChar;
        do {
          switch (jjstateSet[--i]) {
            case 0:
              if ((0x3ff000000000000L & l) != 0L) {
                if (kind > 11)
                  kind = 11;
                jjCheckNAddStates(4, 8);
              }
              else if ((0x1800000000L & l) != 0L) {
                if (kind > 58)
                  kind = 58;
                jjCheckNAdd(6);
              }
              else if (curChar == 39)
                jjCheckNAddStates(9, 13);
              else if (curChar == 34)
                jjCheckNAddStates(14, 18);
              else if (curChar == 46)
                jjCheckNAdd(1);
              break;
            case 1:
              if ((0x3ff000000000000L & l) == 0L)
                break;
              if (kind > 12)
                kind = 12;
              jjCheckNAddTwoStates(1, 2);
              break;
            case 3:
              if ((0x280000000000L & l) != 0L)
                jjCheckNAdd(4);
              break;
            case 4:
              if ((0x3ff000000000000L & l) == 0L)
                break;
              if (kind > 12)
                kind = 12;
              jjCheckNAdd(4);
              break;
            case 5:
              if ((0x1800000000L & l) == 0L)
                break;
              if (kind > 58)
                kind = 58;
              jjCheckNAdd(6);
              break;
            case 6:
              if ((0x3ff001000000000L & l) == 0L)
                break;
              if (kind > 58)
                kind = 58;
              jjCheckNAdd(6);
              break;
            case 7:
              if ((0x3ff000000000000L & l) == 0L)
                break;
              if (kind > 11)
                kind = 11;
              jjCheckNAddStates(4, 8);
              break;
            case 8:
              if ((0x3ff000000000000L & l) == 0L)
                break;
              if (kind > 11)
                kind = 11;
              jjCheckNAdd(8);
              break;
            case 9:
              if ((0x3ff000000000000L & l) != 0L)
                jjCheckNAddTwoStates(9, 10);
              break;
            case 10:
              if (curChar != 46)
                break;
              if (kind > 12)
                kind = 12;
              jjCheckNAddTwoStates(11, 12);
              break;
            case 11:
              if ((0x3ff000000000000L & l) == 0L)
                break;
              if (kind > 12)
                kind = 12;
              jjCheckNAddTwoStates(11, 12);
              break;
            case 13:
              if ((0x280000000000L & l) != 0L)
                jjCheckNAdd(14);
              break;
            case 14:
              if ((0x3ff000000000000L & l) == 0L)
                break;
              if (kind > 12)
                kind = 12;
              jjCheckNAdd(14);
              break;
            case 15:
              if ((0x3ff000000000000L & l) != 0L)
                jjCheckNAddTwoStates(15, 16);
              break;
            case 17:
              if ((0x280000000000L & l) != 0L)
                jjCheckNAdd(18);
              break;
            case 18:
              if ((0x3ff000000000000L & l) == 0L)
                break;
              if (kind > 12)
                kind = 12;
              jjCheckNAdd(18);
              break;
            case 19:
              if (curChar == 34)
                jjCheckNAddStates(14, 18);
              break;
            case 20:
              if ((0xfffffffbffffffffL & l) != 0L)
                jjCheckNAddStates(19, 21);
              break;
            case 22:
              if (curChar == 34)
                jjCheckNAddStates(19, 21);
              break;
            case 23:
              if (curChar == 34 && kind > 14)
                kind = 14;
              break;
            case 24:
              if ((0xfffffffbffffffffL & l) != 0L)
                jjCheckNAddTwoStates(24, 25);
              break;
            case 26:
              if ((0xfffffffbffffffffL & l) != 0L && kind > 15)
                kind = 15;
              break;
            case 27:
              if (curChar == 39)
                jjCheckNAddStates(9, 13);
              break;
            case 28:
              if ((0xffffff7fffffffffL & l) != 0L)
                jjCheckNAddStates(22, 24);
              break;
            case 30:
              if (curChar == 39)
                jjCheckNAddStates(22, 24);
              break;
            case 31:
              if (curChar == 39 && kind > 14)
                kind = 14;
              break;
            case 32:
              if ((0xffffff7fffffffffL & l) != 0L)
                jjCheckNAddTwoStates(32, 33);
              break;
            case 34:
              if ((0xffffff7fffffffffL & l) != 0L && kind > 15)
                kind = 15;
              break;
            default:
              break;
          }
        }
        while (i != startsAt);
      }
      else if (curChar < 128) {
        long l = 1L << (curChar & 077);
        do {
          switch (jjstateSet[--i]) {
            case 0:
            case 6:
              if ((0x7fffffe87fffffeL & l) == 0L)
                break;
              if (kind > 58)
                kind = 58;
              jjCheckNAdd(6);
              break;
            case 2:
              if ((0x2000000020L & l) != 0L)
                jjAddStates(25, 26);
              break;
            case 12:
              if ((0x2000000020L & l) != 0L)
                jjAddStates(27, 28);
              break;
            case 16:
              if ((0x2000000020L & l) != 0L)
                jjAddStates(29, 30);
              break;
            case 20:
              if ((0xffffffffefffffffL & l) != 0L)
                jjCheckNAddStates(19, 21);
              break;
            case 21:
              if (curChar == 92)
                jjstateSet[jjnewStateCnt++] = 22;
              break;
            case 22:
              if (curChar == 92)
                jjCheckNAddStates(19, 21);
              break;
            case 24:
              if ((0xffffffffefffffffL & l) != 0L)
                jjAddStates(31, 32);
              break;
            case 25:
              if (curChar == 92)
                jjstateSet[jjnewStateCnt++] = 26;
              break;
            case 26:
            case 34:
              if ((0xffffffffefffffffL & l) != 0L && kind > 15)
                kind = 15;
              break;
            case 28:
              if ((0xffffffffefffffffL & l) != 0L)
                jjCheckNAddStates(22, 24);
              break;
            case 29:
              if (curChar == 92)
                jjstateSet[jjnewStateCnt++] = 30;
              break;
            case 30:
              if (curChar == 92)
                jjCheckNAddStates(22, 24);
              break;
            case 32:
              if ((0xffffffffefffffffL & l) != 0L)
                jjAddStates(33, 34);
              break;
            case 33:
              if (curChar == 92)
                jjstateSet[jjnewStateCnt++] = 34;
              break;
            default:
              break;
          }
        }
        while (i != startsAt);
      }
      else {
        int hiByte = (int) (curChar >> 8);
        int i1 = hiByte >> 6;
        long l1 = 1L << (hiByte & 077);
        int i2 = (curChar & 0xff) >> 6;
        long l2 = 1L << (curChar & 077);
        do {
          switch (jjstateSet[--i]) {
            case 0:
            case 6:
              if (!jjCanMove_1(hiByte, i1, i2, l1, l2))
                break;
              if (kind > 58)
                kind = 58;
              jjCheckNAdd(6);
              break;
            case 20:
              if (jjCanMove_0(hiByte, i1, i2, l1, l2))
                jjAddStates(19, 21);
              break;
            case 24:
              if (jjCanMove_0(hiByte, i1, i2, l1, l2))
                jjAddStates(31, 32);
              break;
            case 26:
            case 34:
              if (jjCanMove_0(hiByte, i1, i2, l1, l2) && kind > 15)
                kind = 15;
              break;
            case 28:
              if (jjCanMove_0(hiByte, i1, i2, l1, l2))
                jjAddStates(22, 24);
              break;
            case 32:
              if (jjCanMove_0(hiByte, i1, i2, l1, l2))
                jjAddStates(33, 34);
              break;
            default:
              break;
          }
        }
        while (i != startsAt);
      }
      if (kind != 0x7fffffff) {
        jjmatchedKind = kind;
        jjmatchedPos = curPos;
        kind = 0x7fffffff;
      }
      ++curPos;
      if ((i = jjnewStateCnt) == (startsAt = 35 - (jjnewStateCnt = startsAt)))
        return curPos;
      try {
        curChar = input_stream.readChar();
      }
      catch (IOException e) {
        return curPos;
      }
    }
  }

  private final int jjStopStringLiteralDfa_1(int pos, long active0) {
    switch (pos) {
      case 0:
        if ((active0 & 0x80000L) != 0L)
          return 1;
        if ((active0 & 0x50755550070000L) != 0L) {
          jjmatchedKind = 58;
          return 6;
        }
        return -1;
      case 1:
        if ((active0 & 0x105550000000L) != 0L)
          return 6;
        if ((active0 & 0x50650000070000L) != 0L) {
          jjmatchedKind = 58;
          jjmatchedPos = 1;
          return 6;
        }
        return -1;
      case 2:
        if ((active0 & 0x50050000000000L) != 0L)
          return 6;
        if ((active0 & 0x600000070000L) != 0L) {
          jjmatchedKind = 58;
          jjmatchedPos = 2;
          return 6;
        }
        return -1;
      case 3:
        if ((active0 & 0x50000L) != 0L)
          return 6;
        if ((active0 & 0x600000020000L) != 0L) {
          jjmatchedKind = 58;
          jjmatchedPos = 3;
          return 6;
        }
        return -1;
      case 4:
        if ((active0 & 0x400000000000L) != 0L) {
          jjmatchedKind = 58;
          jjmatchedPos = 4;
          return 6;
        }
        if ((active0 & 0x200000020000L) != 0L)
          return 6;
        return -1;
      case 5:
        if ((active0 & 0x400000000000L) != 0L) {
          jjmatchedKind = 58;
          jjmatchedPos = 5;
          return 6;
        }
        return -1;
      case 6:
        if ((active0 & 0x400000000000L) != 0L) {
          jjmatchedKind = 58;
          jjmatchedPos = 6;
          return 6;
        }
        return -1;
      case 7:
        if ((active0 & 0x400000000000L) != 0L) {
          jjmatchedKind = 58;
          jjmatchedPos = 7;
          return 6;
        }
        return -1;
      case 8:
        if ((active0 & 0x400000000000L) != 0L) {
          jjmatchedKind = 58;
          jjmatchedPos = 8;
          return 6;
        }
        return -1;
      default:
        return -1;
    }
  }

  private final int jjStartNfa_1(int pos, long active0) {
    return jjMoveNfa_1(jjStopStringLiteralDfa_1(pos, active0), pos + 1);
  }

  private int jjMoveStringLiteralDfa0_1() {
    switch (curChar) {
      case 33:
        jjmatchedKind = 39;
        return jjMoveStringLiteralDfa1_1(0x2000000000L);
      case 37:
        return jjStopAtPos(0, 53);
      case 38:
        return jjMoveStringLiteralDfa1_1(0x20000000000L);
      case 40:
        return jjStopAtPos(0, 20);
      case 41:
        return jjStopAtPos(0, 21);
      case 42:
        return jjStopAtPos(0, 47);
      case 43:
        jjmatchedKind = 48;
        return jjMoveStringLiteralDfa1_1(0x80000000000000L);
      case 44:
        return jjStopAtPos(0, 25);
      case 45:
        jjmatchedKind = 49;
        return jjMoveStringLiteralDfa1_1(0x200000000000000L);
      case 46:
        return jjStartNfaWithStates_1(0, 19, 1);
      case 47:
        return jjStopAtPos(0, 51);
      case 58:
        return jjStopAtPos(0, 24);
      case 59:
        return jjStopAtPos(0, 26);
      case 60:
        jjmatchedKind = 29;
        return jjMoveStringLiteralDfa1_1(0x200000000L);
      case 61:
        jjmatchedKind = 56;
        return jjMoveStringLiteralDfa1_1(0x800000000L);
      case 62:
        jjmatchedKind = 27;
        return jjMoveStringLiteralDfa1_1(0x80000000L);
      case 63:
        return jjStopAtPos(0, 50);
      case 91:
        return jjStopAtPos(0, 22);
      case 93:
        return jjStopAtPos(0, 23);
      case 97:
        return jjMoveStringLiteralDfa1_1(0x40000000000L);
      case 100:
        return jjMoveStringLiteralDfa1_1(0x10000000000000L);
      case 101:
        return jjMoveStringLiteralDfa1_1(0x201000000000L);
      case 102:
        return jjMoveStringLiteralDfa1_1(0x20000L);
      case 103:
        return jjMoveStringLiteralDfa1_1(0x110000000L);
      case 105:
        return jjMoveStringLiteralDfa1_1(0x400000000000L);
      case 108:
        return jjMoveStringLiteralDfa1_1(0x440000000L);
      case 109:
        return jjMoveStringLiteralDfa1_1(0x40000000000000L);
      case 110:
        return jjMoveStringLiteralDfa1_1(0x14000040000L);
      case 111:
        return jjMoveStringLiteralDfa1_1(0x100000000000L);
      case 116:
        return jjMoveStringLiteralDfa1_1(0x10000L);
      case 123:
        return jjStopAtPos(0, 9);
      case 124:
        return jjMoveStringLiteralDfa1_1(0x80000000000L);
      case 125:
        return jjStopAtPos(0, 10);
      default:
        return jjMoveNfa_1(0, 0);
    }
  }

  private int jjMoveStringLiteralDfa1_1(long active0) {
    try {
      curChar = input_stream.readChar();
    }
    catch (IOException e) {
      jjStopStringLiteralDfa_1(0, active0);
      return 1;
    }
    switch (curChar) {
      case 38:
        if ((active0 & 0x20000000000L) != 0L)
          return jjStopAtPos(1, 41);
        break;
      case 61:
        if ((active0 & 0x80000000L) != 0L)
          return jjStopAtPos(1, 31);
        else if ((active0 & 0x200000000L) != 0L)
          return jjStopAtPos(1, 33);
        else if ((active0 & 0x800000000L) != 0L)
          return jjStopAtPos(1, 35);
        else if ((active0 & 0x2000000000L) != 0L)
          return jjStopAtPos(1, 37);
        else if ((active0 & 0x80000000000000L) != 0L)
          return jjStopAtPos(1, 55);
        break;
      case 62:
        if ((active0 & 0x200000000000000L) != 0L)
          return jjStopAtPos(1, 57);
        break;
      case 97:
        return jjMoveStringLiteralDfa2_1(active0, 0x20000L);
      case 101:
        if ((active0 & 0x100000000L) != 0L)
          return jjStartNfaWithStates_1(1, 32, 6);
        else if ((active0 & 0x400000000L) != 0L)
          return jjStartNfaWithStates_1(1, 34, 6);
        else if ((active0 & 0x4000000000L) != 0L)
          return jjStartNfaWithStates_1(1, 38, 6);
        break;
      case 105:
        return jjMoveStringLiteralDfa2_1(active0, 0x10000000000000L);
      case 109:
        return jjMoveStringLiteralDfa2_1(active0, 0x200000000000L);
      case 110:
        return jjMoveStringLiteralDfa2_1(active0, 0x440000000000L);
      case 111:
        return jjMoveStringLiteralDfa2_1(active0, 0x40010000000000L);
      case 113:
        if ((active0 & 0x1000000000L) != 0L)
          return jjStartNfaWithStates_1(1, 36, 6);
        break;
      case 114:
        if ((active0 & 0x100000000000L) != 0L)
          return jjStartNfaWithStates_1(1, 44, 6);
        return jjMoveStringLiteralDfa2_1(active0, 0x10000L);
      case 116:
        if ((active0 & 0x10000000L) != 0L)
          return jjStartNfaWithStates_1(1, 28, 6);
        else if ((active0 & 0x40000000L) != 0L)
          return jjStartNfaWithStates_1(1, 30, 6);
        break;
      case 117:
        return jjMoveStringLiteralDfa2_1(active0, 0x40000L);
      case 124:
        if ((active0 & 0x80000000000L) != 0L)
          return jjStopAtPos(1, 43);
        break;
      default:
        break;
    }
    return jjStartNfa_1(0, active0);
  }

  private int jjMoveStringLiteralDfa2_1(long old0, long active0) {
    if (((active0 &= old0)) == 0L)
      return jjStartNfa_1(0, old0);
    try {
      curChar = input_stream.readChar();
    }
    catch (IOException e) {
      jjStopStringLiteralDfa_1(1, active0);
      return 2;
    }
    switch (curChar) {
      case 100:
        if ((active0 & 0x40000000000L) != 0L)
          return jjStartNfaWithStates_1(2, 42, 6);
        else if ((active0 & 0x40000000000000L) != 0L)
          return jjStartNfaWithStates_1(2, 54, 6);
        break;
      case 108:
        return jjMoveStringLiteralDfa3_1(active0, 0x60000L);
      case 112:
        return jjMoveStringLiteralDfa3_1(active0, 0x200000000000L);
      case 115:
        return jjMoveStringLiteralDfa3_1(active0, 0x400000000000L);
      case 116:
        if ((active0 & 0x10000000000L) != 0L)
          return jjStartNfaWithStates_1(2, 40, 6);
        break;
      case 117:
        return jjMoveStringLiteralDfa3_1(active0, 0x10000L);
      case 118:
        if ((active0 & 0x10000000000000L) != 0L)
          return jjStartNfaWithStates_1(2, 52, 6);
        break;
      default:
        break;
    }
    return jjStartNfa_1(1, active0);
  }

  private int jjMoveStringLiteralDfa3_1(long old0, long active0) {
    if (((active0 &= old0)) == 0L)
      return jjStartNfa_1(1, old0);
    try {
      curChar = input_stream.readChar();
    }
    catch (IOException e) {
      jjStopStringLiteralDfa_1(2, active0);
      return 3;
    }
    switch (curChar) {
      case 101:
        if ((active0 & 0x10000L) != 0L)
          return jjStartNfaWithStates_1(3, 16, 6);
        break;
      case 108:
        if ((active0 & 0x40000L) != 0L)
          return jjStartNfaWithStates_1(3, 18, 6);
        break;
      case 115:
        return jjMoveStringLiteralDfa4_1(active0, 0x20000L);
      case 116:
        return jjMoveStringLiteralDfa4_1(active0, 0x600000000000L);
      default:
        break;
    }
    return jjStartNfa_1(2, active0);
  }

  private int jjMoveStringLiteralDfa4_1(long old0, long active0) {
    if (((active0 &= old0)) == 0L)
      return jjStartNfa_1(2, old0);
    try {
      curChar = input_stream.readChar();
    }
    catch (IOException e) {
      jjStopStringLiteralDfa_1(3, active0);
      return 4;
    }
    switch (curChar) {
      case 97:
        return jjMoveStringLiteralDfa5_1(active0, 0x400000000000L);
      case 101:
        if ((active0 & 0x20000L) != 0L)
          return jjStartNfaWithStates_1(4, 17, 6);
        break;
      case 121:
        if ((active0 & 0x200000000000L) != 0L)
          return jjStartNfaWithStates_1(4, 45, 6);
        break;
      default:
        break;
    }
    return jjStartNfa_1(3, active0);
  }

  private int jjMoveStringLiteralDfa5_1(long old0, long active0) {
    if (((active0 &= old0)) == 0L)
      return jjStartNfa_1(3, old0);
    try {
      curChar = input_stream.readChar();
    }
    catch (IOException e) {
      jjStopStringLiteralDfa_1(4, active0);
      return 5;
    }
    if (curChar == 110) {
      return jjMoveStringLiteralDfa6_1(active0, 0x400000000000L);
    }
    return jjStartNfa_1(4, active0);
  }

  private int jjMoveStringLiteralDfa6_1(long old0, long active0) {
    if (((active0 &= old0)) == 0L)
      return jjStartNfa_1(4, old0);
    try {
      curChar = input_stream.readChar();
    }
    catch (IOException e) {
      jjStopStringLiteralDfa_1(5, active0);
      return 6;
    }
    if (curChar == 99) {
      return jjMoveStringLiteralDfa7_1(active0, 0x400000000000L);
    }
    return jjStartNfa_1(5, active0);
  }

  private int jjMoveStringLiteralDfa7_1(long old0, long active0) {
    if (((active0 &= old0)) == 0L)
      return jjStartNfa_1(5, old0);
    try {
      curChar = input_stream.readChar();
    }
    catch (IOException e) {
      jjStopStringLiteralDfa_1(6, active0);
      return 7;
    }
    if (curChar == 101) {
      return jjMoveStringLiteralDfa8_1(active0, 0x400000000000L);
    }
    return jjStartNfa_1(6, active0);
  }

  private int jjMoveStringLiteralDfa8_1(long old0, long active0) {
    if (((active0 &= old0)) == 0L)
      return jjStartNfa_1(6, old0);
    try {
      curChar = input_stream.readChar();
    }
    catch (IOException e) {
      jjStopStringLiteralDfa_1(7, active0);
      return 8;
    }

    if (curChar == 111) {
      return jjMoveStringLiteralDfa9_1(active0, 0x400000000000L);
    }
    return jjStartNfa_1(7, active0);
  }

  private int jjMoveStringLiteralDfa9_1(long old0, long active0) {

    if ((active0 &= old0) == 0L) {
      return jjStartNfa_1(7, old0);
    }
    try {

      curChar = input_stream.readChar();
    }
    catch (IOException e) {
      jjStopStringLiteralDfa_1(8, active0);
      return 9;
    }

    if (curChar == 102 && (active0 & 0x400000000000L) != 0L) {
      return jjStartNfaWithStates_1(9, 46, 6);
    }
    return jjStartNfa_1(8, active0);
  }

  private int jjStartNfaWithStates_1(int pos, int kind, int state) {
    jjmatchedKind = kind;
    jjmatchedPos = pos;
    try {
      curChar = input_stream.readChar();
    }
    catch (IOException e) {
      return pos + 1;
    }
    return jjMoveNfa_1(state, pos + 1);
  }

  private int jjMoveNfa_1(int startState, int curPos) {
    int startsAt = 0;
    jjnewStateCnt = 35;
    int i = 1;
    jjstateSet[0] = startState;
    int kind = 0x7fffffff;
    for (; ; ) {
      if (++jjround == 0x7fffffff)
        ReInitRounds();
      if (curChar < 64) {
        long l = 1L << curChar;
        do {
          switch (jjstateSet[--i]) {
            case 0:
              if ((0x3ff000000000000L & l) != 0L) {
                if (kind > 11)
                  kind = 11;
                jjCheckNAddStates(4, 8);
              }
              else if ((0x1800000000L & l) != 0L) {
                if (kind > 58)
                  kind = 58;
                jjCheckNAdd(6);
              }
              else if (curChar == 39)
                jjCheckNAddStates(9, 13);
              else if (curChar == 34)
                jjCheckNAddStates(14, 18);
              else if (curChar == 46)
                jjCheckNAdd(1);
              break;
            case 1:
              if ((0x3ff000000000000L & l) == 0L)
                break;
              if (kind > 12)
                kind = 12;
              jjCheckNAddTwoStates(1, 2);
              break;
            case 3:
              if ((0x280000000000L & l) != 0L)
                jjCheckNAdd(4);
              break;
            case 4:
              if ((0x3ff000000000000L & l) == 0L)
                break;
              if (kind > 12)
                kind = 12;
              jjCheckNAdd(4);
              break;
            case 5:
              if ((0x1800000000L & l) == 0L)
                break;
              if (kind > 58)
                kind = 58;
              jjCheckNAdd(6);
              break;
            case 6:
              if ((0x3ff001000000000L & l) == 0L)
                break;
              if (kind > 58)
                kind = 58;
              jjCheckNAdd(6);
              break;
            case 7:
              if ((0x3ff000000000000L & l) == 0L)
                break;
              if (kind > 11)
                kind = 11;
              jjCheckNAddStates(4, 8);
              break;
            case 8:
              if ((0x3ff000000000000L & l) == 0L)
                break;
              if (kind > 11)
                kind = 11;
              jjCheckNAdd(8);
              break;
            case 9:
              if ((0x3ff000000000000L & l) != 0L)
                jjCheckNAddTwoStates(9, 10);
              break;
            case 10:
              if (curChar != 46)
                break;
              if (kind > 12)
                kind = 12;
              jjCheckNAddTwoStates(11, 12);
              break;
            case 11:
              if ((0x3ff000000000000L & l) == 0L)
                break;
              if (kind > 12)
                kind = 12;
              jjCheckNAddTwoStates(11, 12);
              break;
            case 13:
              if ((0x280000000000L & l) != 0L)
                jjCheckNAdd(14);
              break;
            case 14:
              if ((0x3ff000000000000L & l) == 0L)
                break;
              if (kind > 12)
                kind = 12;
              jjCheckNAdd(14);
              break;
            case 15:
              if ((0x3ff000000000000L & l) != 0L)
                jjCheckNAddTwoStates(15, 16);
              break;
            case 17:
              if ((0x280000000000L & l) != 0L)
                jjCheckNAdd(18);
              break;
            case 18:
              if ((0x3ff000000000000L & l) == 0L)
                break;
              if (kind > 12)
                kind = 12;
              jjCheckNAdd(18);
              break;
            case 19:
              if (curChar == 34)
                jjCheckNAddStates(14, 18);
              break;
            case 20:
              if ((0xfffffffbffffffffL & l) != 0L)
                jjCheckNAddStates(19, 21);
              break;
            case 22:
              if (curChar == 34)
                jjCheckNAddStates(19, 21);
              break;
            case 23:
              if (curChar == 34 && kind > 14)
                kind = 14;
              break;
            case 24:
              if ((0xfffffffbffffffffL & l) != 0L)
                jjCheckNAddTwoStates(24, 25);
              break;
            case 26:
              if ((0xfffffffbffffffffL & l) != 0L && kind > 15)
                kind = 15;
              break;
            case 27:
              if (curChar == 39)
                jjCheckNAddStates(9, 13);
              break;
            case 28:
              if ((0xffffff7fffffffffL & l) != 0L)
                jjCheckNAddStates(22, 24);
              break;
            case 30:
              if (curChar == 39)
                jjCheckNAddStates(22, 24);
              break;
            case 31:
              if (curChar == 39 && kind > 14)
                kind = 14;
              break;
            case 32:
              if ((0xffffff7fffffffffL & l) != 0L)
                jjCheckNAddTwoStates(32, 33);
              break;
            case 34:
              if ((0xffffff7fffffffffL & l) != 0L && kind > 15)
                kind = 15;
              break;
            default:
              break;
          }
        }
        while (i != startsAt);
      }
      else if (curChar < 128) {
        long l = 1L << (curChar & 077);
        do {
          switch (jjstateSet[--i]) {
            case 0:
            case 6:
              if ((0x7fffffe87fffffeL & l) == 0L)
                break;
              if (kind > 58)
                kind = 58;
              jjCheckNAdd(6);
              break;
            case 2:
              if ((0x2000000020L & l) != 0L)
                jjAddStates(25, 26);
              break;
            case 12:
              if ((0x2000000020L & l) != 0L)
                jjAddStates(27, 28);
              break;
            case 16:
              if ((0x2000000020L & l) != 0L)
                jjAddStates(29, 30);
              break;
            case 20:
              if ((0xffffffffefffffffL & l) != 0L)
                jjCheckNAddStates(19, 21);
              break;
            case 21:
              if (curChar == 92)
                jjstateSet[jjnewStateCnt++] = 22;
              break;
            case 22:
              if (curChar == 92)
                jjCheckNAddStates(19, 21);
              break;
            case 24:
              if ((0xffffffffefffffffL & l) != 0L)
                jjAddStates(31, 32);
              break;
            case 25:
              if (curChar == 92)
                jjstateSet[jjnewStateCnt++] = 26;
              break;
            case 26:
            case 34:
              if ((0xffffffffefffffffL & l) != 0L && kind > 15)
                kind = 15;
              break;
            case 28:
              if ((0xffffffffefffffffL & l) != 0L)
                jjCheckNAddStates(22, 24);
              break;
            case 29:
              if (curChar == 92)
                jjstateSet[jjnewStateCnt++] = 30;
              break;
            case 30:
              if (curChar == 92)
                jjCheckNAddStates(22, 24);
              break;
            case 32:
              if ((0xffffffffefffffffL & l) != 0L)
                jjAddStates(33, 34);
              break;
            case 33:
              if (curChar == 92)
                jjstateSet[jjnewStateCnt++] = 34;
              break;
            default:
              break;
          }
        }
        while (i != startsAt);
      }
      else {
        int hiByte = curChar >> 8;
        int i1 = hiByte >> 6;
        long l1 = 1L << (hiByte & 077);
        int i2 = (curChar & 0xff) >> 6;
        long l2 = 1L << (curChar & 077);
        do {
          switch (jjstateSet[--i]) {
            case 0:
            case 6:
              if (!jjCanMove_1(hiByte, i1, i2, l1, l2))
                break;
              if (kind > 58)
                kind = 58;
              jjCheckNAdd(6);
              break;
            case 20:
              if (jjCanMove_0(hiByte, i1, i2, l1, l2))
                jjAddStates(19, 21);
              break;
            case 24:
              if (jjCanMove_0(hiByte, i1, i2, l1, l2))
                jjAddStates(31, 32);
              break;
            case 26:
            case 34:
              if (jjCanMove_0(hiByte, i1, i2, l1, l2) && kind > 15)
                kind = 15;
              break;
            case 28:
              if (jjCanMove_0(hiByte, i1, i2, l1, l2))
                jjAddStates(22, 24);
              break;
            case 32:
              if (jjCanMove_0(hiByte, i1, i2, l1, l2))
                jjAddStates(33, 34);
              break;
            default:
              break;
          }
        }
        while (i != startsAt);
      }
      if (kind != 0x7fffffff) {
        jjmatchedKind = kind;
        jjmatchedPos = curPos;
        kind = 0x7fffffff;
      }
      ++curPos;
      if ((i = jjnewStateCnt) == (startsAt = 35 - (jjnewStateCnt = startsAt)))
        return curPos;
      try {
        curChar = input_stream.readChar();
      }
      catch (IOException e) {
        return curPos;
      }
    }
  }

  private static final int[] jjnextStates = { //
          0, 1, 3, 5, 8, 9, 10, 15, 16, 28, 29, 31, 32, 33, 20, 21, 23, 24, //
          25, 20, 21, 23, 28, 29, 31, 3, 4, 13, 14, 17, 18, 24, 25, 32, 33,
  };

  private static final boolean jjCanMove_0(int hiByte, int i1, int i2, long l1, long l2) {
    if (hiByte == 0) {
      return ((jjbitVec2[i2] & l2) != 0L);
    }
    return (jjbitVec0[i1] & l1) != 0L;
  }

  private static final boolean jjCanMove_1(int hiByte, int i1, int i2, long l1, long l2) {
    return switch (hiByte) {
      case 0 -> ((jjbitVec4[i2] & l2) != 0L);
      case 48 -> ((jjbitVec5[i2] & l2) != 0L);
      case 49 -> ((jjbitVec6[i2] & l2) != 0L);
      case 51 -> ((jjbitVec7[i2] & l2) != 0L);
      case 61 -> ((jjbitVec8[i2] & l2) != 0L);
      default -> (jjbitVec3[i1] & l1) != 0L;
    };
  }

  private void ReInitRounds() {
    int i;
    jjround = 0x80000001;
    for (i = 35; i-- > 0; )
      jjrounds[i] = 0x80000000;
  }

  /** Switch to specified lex state. */
  public void SwitchTo(int lexState) {
    if (lexState >= 3 || lexState < 0) {
      throw new TokenMgrError("Error: Ignoring invalid lexical state : " + lexState
                                      + ". State unchanged.", TokenMgrError.INVALID_LEXICAL_STATE);
    }
    else
      curLexState = lexState;
  }

  protected Token jjFillToken() {
    final Token t;
    final String curTokenImage;
    final int beginLine;
    final int endLine;
    final int beginColumn;
    final int endColumn;
    String im = jjstrLiteralImages[jjmatchedKind];
    curTokenImage = (im == null) ? input_stream.GetImage() : im;
    beginLine = input_stream.getBeginLine();
    beginColumn = input_stream.getBeginColumn();
    endLine = input_stream.getEndLine();
    endColumn = input_stream.getEndColumn();
    t = Token.newToken(jjmatchedKind);
    t.kind = jjmatchedKind;
    t.image = curTokenImage;

    t.beginLine = beginLine;
    t.endLine = endLine;
    t.beginColumn = beginColumn;
    t.endColumn = endColumn;

    return t;
  }

  int curLexState = 0;
  //  int defaultLexState = 0;
  int jjnewStateCnt;
  int jjround;
  int jjmatchedPos;
  int jjmatchedKind;

  /** Get the next Token. */
  public Token getNextToken() {
    Token matchedToken;
    int curPos = 0;

    EOFLoop:
    for (; ; ) {
      try {

        curChar = input_stream.BeginToken();
      }
      catch (IOException e) {
        jjmatchedKind = 0;
        matchedToken = jjFillToken();
        return matchedToken;
      }
      image.setLength(0);

      switch (curLexState) {
        case 0 -> {
          jjmatchedKind = 0x7fffffff;
          jjmatchedPos = 0;
          curPos = jjMoveStringLiteralDfa0_0();
        }
        case 1 -> {
          try {
            input_stream.backup(0);
            while (curChar <= 32 && (0x100002600L & (1L << curChar)) != 0L)
              curChar = input_stream.BeginToken();
          }
          catch (IOException e1) {
            continue EOFLoop;
          }
          jjmatchedKind = 0x7fffffff;
          jjmatchedPos = 0;
          curPos = jjMoveStringLiteralDfa0_1();
          if (jjmatchedPos == 0 && jjmatchedKind > 62) {
            jjmatchedKind = 62;
          }
        }
        case 2 -> {
          try {

            input_stream.backup(0);
            while (curChar <= 32 && (0x100002600L & (1L << curChar)) != 0L)
              curChar = input_stream.BeginToken();
          }
          catch (IOException e1) {
            continue EOFLoop;
          }
          jjmatchedKind = 0x7fffffff;
          jjmatchedPos = 0;
          curPos = jjMoveStringLiteralDfa0_2();
          if (jjmatchedPos == 0 && jjmatchedKind > 62) {
            jjmatchedKind = 62;
          }
        }
      }
      if (jjmatchedKind != 0x7fffffff) {
        if (jjmatchedPos + 1 < curPos)
          input_stream.backup(curPos - jjmatchedPos - 1);
        if ((jjtoToken[jjmatchedKind >> 6] & (1L << (jjmatchedKind & 077))) != 0L) {
          matchedToken = jjFillToken();
          TokenLexicalActions(matchedToken);
          if (jjnewLexState[jjmatchedKind] != -1)
            curLexState = jjnewLexState[jjmatchedKind];
          return matchedToken;
        }
        else {
          if (jjnewLexState[jjmatchedKind] != -1)
            curLexState = jjnewLexState[jjmatchedKind];
          continue EOFLoop;
        }
      }
      int error_line = input_stream.getEndLine();
      int error_column = input_stream.getEndColumn();
      String error_after = null;
      boolean EOFSeen = false;
      try {
        input_stream.readChar();
        input_stream.backup(1);
      }
      catch (IOException e1) {
        EOFSeen = true;
        error_after = curPos <= 1 ? Constant.BLANK : input_stream.GetImage();
        if (curChar == '\n' || curChar == '\r') {
          error_line++;
          error_column = 0;
        }
        else
          error_column++;
      }
      if (!EOFSeen) {
        input_stream.backup(1);
        error_after = curPos <= 1 ? Constant.BLANK : input_stream.GetImage();
      }
      throw new TokenMgrError(EOFSeen, curLexState, error_line, error_column, error_after, curChar, TokenMgrError.LEXICAL_ERROR);
    }
  }

  void TokenLexicalActions(Token matchedToken) {
    switch (jjmatchedKind) {
      case 2 -> {
        image.append(jjstrLiteralImages[2]);
        stack.push(DEFAULT);
      }
      case 3 -> {
        image.append(jjstrLiteralImages[3]);
        stack.push(DEFAULT);
      }
      case 9 -> {
        image.append(jjstrLiteralImages[9]);
        stack.push(curLexState);
      }
      case 10 -> {
        image.append(jjstrLiteralImages[10]);
        SwitchTo(stack.pop());
      }
      default -> {
      }
    }
  }

  private void jjCheckNAdd(int state) {
    if (jjrounds[state] != jjround) {
      jjstateSet[jjnewStateCnt++] = state;
      jjrounds[state] = jjround;
    }
  }

  private void jjAddStates(int start, int end) {
    do {
      jjstateSet[jjnewStateCnt++] = jjnextStates[start];
    }
    while (start++ != end);
  }

  private void jjCheckNAddTwoStates(int state1, int state2) {
    jjCheckNAdd(state1);
    jjCheckNAdd(state2);
  }

  private void jjCheckNAddStates(int start, int end) {
    do {
      jjCheckNAdd(jjnextStates[start]);
    }
    while (start++ != end);
  }

}
